{
  "hash": "1f449c2970f172cb2e5171e88af5589d",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Causal Inference: Estimation of ATE and CATE\"\ndate: \"2025-APR-29\"\nformat:\n  html:\n    warnings: FALSE\n    error: FALSE\n    messages: FALSE\n    code-overflow: scroll\n    highlight-style: kate\n    code-tools:\n      source: true\n      toggle: FALSE\nhtml-math-method: katex\nreference-location: margin\ncitation-location: margin\ncap-location: margin\ncode-block-border-left: true\n---\n\n\n\n\n::: {.callout-note}\n**Required**\n- [@vanderweele2020] [link](https://www.dropbox.com/scl/fi/srpynr0dvjcndveplcydn/OutcomeWide_StatisticalScience.pdf?rlkey=h4fv32oyjegdfl3jq9u1fifc3&dl=0)\n\n\n**Optional**\n- [@suzuki2020] [link](https://www.dropbox.com/scl/fi/4midxwr9ltg9oce02e0ss/suzuki-causal-diagrams.pdf?rlkey=uktzf3nurtgpbj8m4h0xz82dn&dl=0)\n- [@Bulbulia2024PracticalGuide] [link](https://osf.io/preprints/psyarxiv/uyg3d)\n- [@hoffman2023] [link](https://arxiv.org/pdf/2304.09460.pdf)\n:::\n\n::: {.callout-important}\n## Key concepts for the test(s):\n  - **Counfounding vs Confounder**\n  - **Causal Estimand, Statistical Estimand, Statistical Estimator**\n  - **Inverse probabilitiy of treatment weights using propensity scores: modelling the exposure or treatment, not the outcome.**\n  - **Subgroup analysis using propensity scores**\n:::\n\n::: {.callout-important}\n## For the lab, copy and paste code chunks following the \"LAB\" section.\n:::\n\n\n# Seminar\n\n## Learning Outcomes\n\n- You will learn how to state a causal question in a three-wave panel\n- You will learn how to identify causal effects in a three-waves of panel data.\n- How to do Propensity-score weighting: modelling the exposure or treatment, not the outcome.\n<!-- - Outcome modelling: modelling the outcome, with the treatment included in the model -->\n<!-- - Doubly robust estimation: model both the treatment and the outcome.** -->\n- Subgroup analysis by doubly-robust estimation\n\n\n<!-- - You will learn how to write a report statement that formulates a causal question, names a population of interest, and constructs a causal diagram that explains whether and how to identify a causal effect from data.  -->\n\n\n### Why is this lesson important?\n\n<!-- Recall that in psychology, our task is to answer some questions about how people think and behave. In cross-cultural psychology, these questions are typically comparative. -->\n\n<!-- Our first task is clearly define that question. Our second task is to answer that question. -->\n\nThe methods you will learn today will help you to define and answer comparative questions in psychology. \n\n\n## Review: The Fundamental Problem of Causal Inference as a Missing Data Problem\n\nRecall the fundamental problem of causal inference, returning to the question of whether bilingualism improves cognitive abilities:\n\n-   $Y_i^{a = 1}$: The cognitive ability of child $i$ if they were bilingual. This is the counterfactual outcome when A = 1.\n-   $Y_i^{a = 0}$:: The cognitive ability of child $i$ if they were monolingual. This is the counterfactual outcome when A = 0.\n\nThe causal effect of bilingualism on cognitive ability for individual $i$ is then defined as the difference between these potential outcomes:\n\n$$\n\\text{Causal Effect}_i = Y_i^{a=1} - Y_i^{a=0} \n$$\n\nWe say there is a causal effect if:\n\n$$\nY_i^{a=1} - Y_i^{a=0}  \\neq 0\n$$\n\nHowever, we only observe one of the potential outcomes for each child. The other outcome is not observed because physics prevents a child from both receiving and not receiving bilingual exposure.\n\nThe fact that causal contrasts are not observed in individuals is called \"The fundamental problem of causal inference.\"\n\nAlthough we typically cannot observe individual causal effects, we can obtain average causal effects when certain assumptions are satisfied.\n\n```{=tex}\n\\begin{align}\nE(\\delta) = E(Y^{a=1} - Y^{a=0})\\\\\n          ~  = E(Y^{a=1}) - E(Y^{a=0}) \\\\\n          ~  = ATE\n\\end{align}\n```\nWe may identify average causal effects from the data when the following assumptions are met:\n\n-   **Causal Consistency:** The exposure values under comparisons correspond to well-defined interventions that, in turn, correspond to the treatment versions in the data.[]\n-   **Positivity:** The probability of receiving every value of the exposure within all strata of co-variates is greater than zero []\n-   **Exchangeability:** The conditional probability of receiving every value of an exposure level, though not decided by the investigators, depends only on the measured covariates []\n\nFurther assumptions:\n\n-   **No Interference,** also known as the **Stable Unit Treatment Value Assumption** (SUTVA), requires that the treatment given to one unit (e.g., person, group, organization) does not interfere with the potential outcomes of another unit. Put differently, there are no \"spillover\" effects. Note: this assumption may be thought to be part of causal consistency, namely individual has only one potential outcome under each treatment condition.\n-   **Correctly specified model**: the requirement that the underlying statistical model used to estimate causal effects accurately represents the true relationships between the variables of interest. We say the model should be able to capture \"the functional form\" of the relationship between the treatment, the outcome, and any covariates. The model's functional form should be flexible enough to capture the true underlying relationship. The estimated causal effects may be biased if the model's functional form is incorrect. Additionally, the model must handle omitted variable bias by including all relevant confounders and should correctly handle missing data from non-response or loss-to follow up. We will return to the bias arising from missing data in the weeks ahead. For now, it is important to note that causal inference assumes that our model is correctly specified.\n\n\n## Subgroup analysis\n\n<!-- In causal inference, these two concepts are related but have distinct meanings. -->\n\n<!-- Let $Y_{a}$ denote the counterfactual outcome Y when the experimental intervention $A$ is set to level $a$. Let $Y_{r}$ denote the counterfactual outcome $Y$ when another experimental intervention $R$ is set to level $r$. Following VanderWeele (2009), we can define interaction and effect modification as follows: -->\n\n<!-- 1.  Interaction (causal interaction) on the difference scale, conditional on confounders $L$, occurs when: -->\n\n<!-- $$E(Y^{a1,r1}|L=l) - E(Y^{a0,r1}|L=l) \\neq E(Y^{a1,r0}|L=l) - E(Y^{a0,r0}|L=l)$$ -->\n\n<!-- In this case, we are considering a double intervention, and interaction occurs when the combined effect of interventions $A$ and $R$ is not equal to the sum of their individual effects. -->\n\nRedcall, **Effect Modification** (also known as \"heterogeneity of treatment effects\", and \"Effect-measure modification\") occurs when the causal effect of intervention $A$ varies across different levels of another variable $R$:\n\n$$E(Y^{a=1}|G=g_1, L=l) - E(Y^{a=0}|G=g_1, L=l) \\neq E(Y^{a=1}|G=g_2, L=l) - E(Y^{a=0}|G=g_2, L=l)$$\n\nEffect modification indicates that the magnitude of the causal effect of intervention $A$ is related to the modifier variable $G$ level. As discussed last week, effect modification can be observed even when there is no direct causal interaction between the treatment and the modifier variable. We noted that **interaction in causal inference refers to a situation where the combined effect of two interventions is not equal to the sum of their individual effects**. **Effect modification, on the other hand, occurs when the causal effect of one intervention varies across different levels of another variable.**\n\n\nWe also noted that \n\n> **For comparative research, we are typically interested in effect-modification, which requires subgroup analysis.**\n\n\n### Causal Estimand, Statistical Estimand, Statistical Estimator\n\nLet's set subgroup analysis to the side for a moment and begin focussing on statistical estimation.  \n\nSuppose a researcher wants to understand the causal effect of marriage on individual happiness. Participants in the study are surveyed for their marital status (\"married\" or \"not married\") and their self-reported happiness on a scale from 1 to 10.\n\n#### Causal Estimand\n\n- **Definition**: The causal estimand is the specific quantity or parameter that we aim to estimate to understand the causal effect of an intervention or treatment on an outcome.\n\n- **Example**: Here, the **Causal Estimand** would be the Average Treatment Effect (ATE) of being married on happiness. Specifically, we define the ATE as the difference in the potential outcomes of happiness if all individuals were married versus if no individuals were married:\n\n  $$\n  \\text{ATE} = E[Y^{a=1} - Y^{a=0}]\n  $$\n\n\n  Here, $Y^{a=1}$ represents the potential happiness score if an individual is married, and $Y^{a=0}$ if they are not married.\n\n\n#### Next step: Are Causal Assumptions Met? \n\n- Identification (Exchangeability): balance in the confounders across the treatments to be compared\n\n- Consistency: well-defined interventions\n\n- Positivity: treatments occur within levels of covariates $L$\n\n\n#### Statistical Estimand (next step)\n\n- **The problem**: how do we bridge the gap between potential outcomes and data? \n\n- **Definition**: the statistical estimand is the parameter or function that summarises the relationship between variables as described by a statistical model applied to data. \n\n- **Example**: for our study, the **Statistical Estimand** might be the mean difference in happiness scores between individuals who are married and those who are not, as derived from a linear regression model:\n\n  $$\n  \\text{Happiness} = \\beta_0 + \\beta_1 \\times \\text{Married} + \\epsilon\n  $$\n\n  In this equation, $\\beta_1$ represents the estimated difference in happiness scores between the married and non-married groups.\n\n#### Statistical Estimator\n\n- **Definition**: a statistical estimator is a rule or method by which a numerical estimate of a statistical estimand is calculated from the data.\n\n- **Example**: in our marriage study, the **Statistical Estimator** for $\\beta_1$ is the ordinary least squares (OLS) estimator. This estimator is used to calculate $\\beta_1$ from the sample data provided by the survey. It provides an estimate of the impact of being married on happiness, calculated using:\n  $$\n  \\hat{\\beta}_1 = \\frac{\\sum_{i=1}^n (X_i - \\bar{X})(Y_i - \\bar{Y})}{\\sum_{i=1}^n (X_i - \\bar{X})^2}\n  $$\n  where $X_i$ is a binary indicator for being married (1 for married, 0 for not married), $Y_i$ is the observed happiness score, and $\\bar{X}$, $\\bar{Y}$ are the sample means of $X$ and $Y$, respectively.\n\n\n(Note: you will not need to know this equation for the quiz)\n\n\nThe upshot, we anchor our causal inquiries within a mult-step framework of data analysis. This involves: \n\n1. clearly defining our causal estimand within a specified *target population,*\n2. clarifying assumptions, & especially identification assumptions, \n3. describing a statistical strategy for extracting this estimand from the data, and then \n4. applying an algorithm that embodies this statistical method.\n\n\n## Methods for Statistical Estimation in Causal Inference: Inverse Probability of Treatment Weights Using Propensity Scores\n\nLast week, we discussed confounding control using regression adjustment. Recall the formula for the average treatment effect (ATE) when conditioning on a set of covariates $L$:\n\n$$\n\\begin{aligned}\n\\text{ATE} = E[Y^{a=1} \\mid L = l] - E[Y^{a=0} \\mid L = l] \\quad \\text{for any value of } l\n\\end{aligned}\n$$\n\n> \"We say that a set $L$ of measured non-descendants of $L$ is a sufficient set for confounding adjustment when conditioning on $L$ blocks all backdoor paths—that is, the treated and the untreated are exchangeable within levels of $L$\" (Hernán & Robins, *Causal Inference*, p. 86).\n\nThis formula calculates the expected outcome difference between treated ($a=1$) and untreated ($a=0$) groups, given a specific value of the covariates $l$.\n\nInverse Probability of Treatment Weighting (IPTW) takes a different approach. We create a pseudo-population where the treatment assignment is independent of the observed covariates by assigning weights to each individual based on their propensity scores.\n\n**We do this by modelling the treatment**\n\nDenote the treatment indicator by $A$, where $A = 1$ if an individual receives treatment and $A = 0$ otherwise. $L$ represents the vector of observed covariates, and $Y^a$ the potential outcomes. The propensity score, $e(L)$, is defined as the probability of receiving the treatment given the observed covariates:\n\n$$\n\\hat{e}(L) = P(A = 1 \\mid L)\n$$\n\nTo obtain IPTW weights, compute the inverse probability of treatment:\n\n$$\nv_i = \\frac{A_i}{\\hat{e}(L_i)} + \\frac{1 - A_i}{1 - \\hat{e}(L_i)}\n$$\n\nWhich simplifies to \n\n$$\nv_i = \n\\begin{cases} \n\\frac{1}{\\hat{e}} & \\text{if } A_i = 1 \\\\\n\\frac{1}{1-\\hat{e}} & \\text{if } A_i = 0 \n\\end{cases}\n$$\n\nwhere $v_i$ is the IPTW weight for individual $i$, $A_i$ is the treatment indicator for individual $i$, and $\\hat{e}(L_i)$ is the estimated propensity score for individual $i$.   \n\nHow might we use these weights to obtain causal effect estimates?\n\n\n\n## Marginal Structural Models (MSMs)\n\nMarginal Structural Models (MSMs) estimate causal effects without requiring an \"outcome model\" that stratifies on covariates. Rather, MSMs employ weights derived from the inverse probability of treatment weighting (IPTW) to create a pseudo-population in which the distribution of covariates is independent of treatment assignment over time.\n\nThe general form of an MSM can be expressed as follows:\n\n$$\nE[Y^a] = \\beta_0 + \\beta_1a\n$$\n\nwhere $E[Y^a]$ is the expected outcome under treatment $a$  and $\\beta_0$ and $\\beta_1$ are parameters estimated by fitting the weighted model. Again, the weights used in the MSM, typically derived from the IPTW (or another treatment model), adjust for the confounding, allowing the model to estimate the unbiased effect of the treatment on the outcome without requiring covariates in the model.\n\nWhere do weights fit in?   Note, we have $E[Y^a]$ in please of $E[Y|A=a]$.  When applying propensity score weights in the linear regression model $E[Y^a] = \\beta_0 + \\beta_1a$, each observation is weighted by $v_i$, such that $v_i(\\beta_0 + \\beta_1a)$. This changes the estimation process to focus on a weighted sum of outcomes, where each individual's contribution is adjusted to reflect their probability of receiving the treatment, given their covariates.\n\n\n## Interpretation of $\\beta_0$ and $\\beta_1$  in a Marginal Structural Model\n\n### Binary Treatment\n\nIn models where the treatment $a$ is binary (e.g., $a = 0$ or $a = 1$), such as in many causal inference studies:\n\n- **$\\beta_0$**: the expected value of the outcome $Y$ when the treatment is not applied ($a = 0$). This is the baseline level of the outcome in the absence of treatment.\n- **$\\beta_1$**: the change in the expected outcome when the treatment status changes from 0 to 1. In logistic regression, $\\beta_1$ represents the log-odds ratio of the outcome for the treatment group relative to the control group. In linear regression, $\\beta_1$ quantifies the difference in the average outcome between the treated and untreated groups.\n\n### Continuous Treatment\n\nWhen the treatment $a$ is continuous, the interpretation of $\\beta_0$ and $\\beta_1$ adjusts slightly:\n\n- **$\\beta_0$**: represents the expected value of the outcome $Y$ when the treatment $a$ is at its reference value (often zero). \n- **$\\beta_1$**: represents the expected change in the outcome for each unit increase in the treatment. In this case, $\\beta_1$ measures the gradient or slope of the relationship between the treatment and the outcome. For every one-unit increase in treatment, the outcome changes by $\\beta_1$ units, assuming all other factors remain constant.\n\n\n<!-- ### Example: Binary treatment, Binary outcome -->\n\n<!-- ### Logistic Regression Model -->\n\n<!-- In the logistic regression (binary outcomes), the Marginal Structural Model (MSM) model is specified as: -->\n<!-- $$ -->\n<!-- \\text{Logit}(E[Y^a]) = \\beta_0 + \\beta_1 a, -->\n<!-- $$ -->\n\n<!-- where $a$ is the treatment indicator (0 for no treatment, 1 for treatment). -->\n\n<!-- ### Calculation for$Y^{a=0}$(No Treatment) -->\n\n<!-- - **Model Simplification**: when$a = 0$(no treatment), the logit model simplifies to: -->\n\n<!--  $$ -->\n<!--   \\text{Logit}(E[Y^{a=0}]) = \\beta_0. -->\n<!--  $$ -->\n\n\n<!-- - **Expected Outcome**: To find$E[Y^{a=0}]$, convert the logit back to probability: -->\n\n<!--  $$ -->\n<!--   E[Y^{a=0}] = \\frac{e^{\\beta_0}}{1 + e^{\\beta_0}} -->\n<!--  $$ -->\n\n<!--   This formula gives the predicted probability of the outcome occurring when there is no treatment. -->\n\n<!-- ### Calculation for$Y^{a=1}$(Treatment Given) -->\n\n<!-- - **Model Specification**: when$a = 1$(treatment given), the logit model is: -->\n\n<!--  $$ -->\n<!--   \\text{Logit}(E[Y^{a=1}]) = \\beta_0 + \\beta_1. -->\n<!--  $$ -->\n\n<!-- - **Expected Outcome**: To find$E[Y^{a=1}]$, similarly convert the logit to probability: -->\n\n<!--  $$ -->\n<!--   E[Y^{a=1}] = \\frac{e^{\\beta_0 + \\beta_1}}{1 + e^{\\beta_0 + \\beta_1}}. -->\n<!--  $$ -->\n\n<!--   This is the predicted probability of the outcome occurring when the treatment is applied. -->\n\n<!-- ### Example of MSM -->\n\n<!-- Suppose$\\beta_0 = -0.5$and$\\beta_1 = 0.8$. Then: -->\n\n<!-- - **No Treatment**:  -->\n\n<!--  $$ -->\n<!--   E[Y^{a=0}] = \\frac{e^{-0.5}}{1 + e^{-0.5}} \\approx \\frac{0.607}{1.607} \\approx 0.378, -->\n<!--  $$ -->\n\n\n<!-- indicating a 37.8% probability of the outcome occurring without treatment. -->\n\n<!-- - **With Treatment**: -->\n<!--  $$ -->\n<!--   E[Y^{a=1}] = \\frac{e^{-0.5 + 0.8}}{1 + e^{-0.5 + 0.8}} = \\frac{e^{0.3}}{1 + e^{0.3}} \\approx \\frac{1.35}{2.35} \\approx 0.574, -->\n<!--  $$ -->\n\n<!-- indicating a 57.4% probability of the outcome occurring with treatment. -->\n\n\n###  How can we apply marginal structural models in subgroups? \n\n\n### Assumptions\n\n- **Model assumptions**: the treatment model is correctly specified.\n- **Causal assumptions**: all confounders are appropriately controlled, positivity and consistency assumptions hold.\n\n\n### Calculating Treatment Weights (Propensity Scores) and Confounding Control in Subgroups\n\nWe may often achieve greater balance when conducting weighted analyses in subgroups by estimating propensity scores *within* these subgroups. The propensity score $ e(L, G) $ is the conditional probability of receiving the exposure $ A = 1 $, given the covariates $ L $ and subgroup indicator $ G $. This is often modelled using logistic regression or other methods that ensure covariate balance\nWe define the estimated propensity score as follows:\n\n$$\n\\hat{e} = P(A = 1 \\mid L, G) = f_A(L, G; \\theta_A)\n$$\n\nHere, $ f_A(L, G; \\theta_A) $ is the statistical model estimating the probability of exposure $A = 1$ given covariates $L$ and subgroup $G$. We then calculate the weights for each individual, denoted $v$, using the estimated propensity score:\n\n$\\theta_A$ encapsulates all the coefficients (parameters) in this model, including intercepts, slopes, and potentially other parameters depending on the model complexity (e.g., interaction terms, non-linear effects...etc).\n\nThese weights $v$ depend on $A$ and are calculated as the inverse of the propensity score for exposed individuals and as the inverse of $ 1-\\hat{e} $ for unexposed individuals.\n\nPropensity scores are estimated *separately* within strata of the subgroup to control for potential confounding tailored to each subgroup. These weights $v$ are specific to each individual in subgroup $G$. In the lab, we will clarify how to fit models to estimate contrasts for the causal effects within groups $\\hat{\\delta}_{g}, \\hat{\\delta}_{g'}$, etc., and how to obtain estimates for group-wise differences:\n\n$$\n\\hat{\\gamma} = \\overbrace{\\big( \\hat{E}[Y^a \\mid G=g] - \\hat{E}[Y^{a'} \\mid G=g] \\big)}^{\\hat{\\delta}_g} - \\overbrace{\\big( \\hat{E}[Y^{a'} \\mid G=g'] - \\hat{E}[Y^a \\mid G=g'] \\big)}^{\\hat{\\delta}_{g'}}\n$$\n\n\n- **$\\hat{E}[Y^a \\mid G=g]$**: Estimated expected outcome when treatment $a$ is applied to subgroup $G=g$.\n- **$\\hat{E}[Y^{a'} \\mid G=g]$**: Estimated expected outcome when a different treatment or control $a'$ is applied to the same subgroup $G=g$.\n- **$\\hat{\\delta}_g$**: Represents the estimated treatment effect within subgroup $G=g$, computed as the difference in expected outcomes between treatment $a$ and $a'$ within this subgroup.\n\n- **$\\hat{E}[Y^{a'} \\mid G=g']$**: Estimated expected outcome when treatment $a'$ is applied to a different subgroup $G=g'$.\n- **$\\hat{E}[Y^a \\mid G=g']$**: Estimated expected outcome when treatment $a$ is applied to subgroup $G=g'$.\n- **$\\hat{\\delta}_{g'}$**: Represents the estimated treatment effect within subgroup $G=g'$, computed as the difference in expected outcomes between treatment $a'$ and $a$ within this subgroup.\n\n- **$\\hat{\\gamma}$**: The overall measure calculated from your formula represents the difference in treatment effects between two subgroups, $G=g$ and $G=g'$. It quantifies how the effect of switching between treatments $a$ and $a'$ differs across the two subgroups.\n\n\n### Considerations\n\n- **Estimation**: to estimate the expected outcomes $\\hat{E}[Y^a \\mid G]$ and $\\hat{E}[Y^{a'} \\mid G]$, we require statistical models. If we use regression, we include interaction terms between treatment and subgroup indicators to directly estimate subgroup-specific treatment effects. Our use depends on correct model specification.\n- **Confidence intervals**: we may compute confidence intervals for $\\hat{\\gamma}$ using bootstrap, the delta method, or -- in our excercises -- simulation based methods.\n- **Causal assumptions**: again, a causal interpretation of $\\hat{\\gamma}$ relies on satisfying both causal assumptions and modelling assumptions.  Here, we have described estimation using propensity scores.\n\n\n## Doubly Robust Estimation\n\nWe can combine regression-based estimation with propensity score estimation to obtain *doubly robust* estimation. I will walk you through the steps in the lab. The TL;DR is this: doubly robust estimation reduces reliance on correct model specification. If either the PS model or the regression model is correctly specified, the model will be unbiased -- if the other causal inference assumptions are met.\n\nWe cannot know whether these assumptions are met, we will need to do a sensitivity analysis, the topic of next week.\n\nI'll show you in lab how to employ simulation-based inference methods to compute standard errors and confidence intervals, following the approaches suggested by Greifer (2023)[].\n\n## Readings:\n\nNoah Griefer's Software and Blogs: [https://ngreifer.github.io/blog/subgroup-analysis-psm/](https://ngreifer.github.io/blog/)\n\n\n# Lab\n\n\nToday we estimate causal effects\n\n::: {.cell}\n\n```{.r .cell-code}\n# uncomment, update the margot package\n# devtools::install_github(\"go-bayes/margot\")\n\n# load packages\nlibrary(tidyverse)\nlibrary(margot)\nlibrary(skimr)\nlibrary(naniar)\nlibrary(WeightIt)\nlibrary(clarify)\nlibrary(MatchThem)\nlibrary(cobalt)\nlibrary(MatchIt)\nlibrary(kableExtra)\nlibrary(lmtp)\nlibrary(SuperLearner)\nlibrary(ranger)\nlibrary(xgboost)\nlibrary(nnls)\nlibrary(mice)\n\nif (!requireNamespace(\"doParallel\", quietly = TRUE)) {\n  install.packages(\"doParallel\")\n}\nif (!requireNamespace(\"foreach\", quietly = TRUE)) {\n  install.packages(\"foreach\")\n}\nlibrary(doParallel)\nlibrary(foreach)\n# createmiceadds# create a folder names saved (you should have done this last week).\n# set your path to this folder\n\n# save in cloud if using github\npush_mods <- here::here('/Users/joseph/Library/CloudStorage/Dropbox-v-project/data/saved')\n\n# check it is correct\n# uncomment, check\n#push_mods\n\n# set seed for reproducability\nset.seed(123)\n\n\n# eliminate haven labels\ndf_nz <- as.data.frame(df_nz)\ndf_nz <- haven::zap_formats(df_nz)\ndf_nz <- haven::zap_label(df_nz)\ndf_nz <- haven::zap_widths(df_nz)\n\n# read functions\n# source(\"/Users/joseph/GIT/templates/functions/funs.R\")\n\n# experimental functions (more functions)\n# source(\n#   \"https://raw.githubusercontent.com/go-bayes/templates/main/functions/experimental_funs.R\"\n# )\n# # set exposure name\n\nname_exposure <-  \"perfectionism\"\n\n# check missing values\nskimr::skim(df_nz) |> arrange(n_missing)\n```\n\n::: {.cell-output-display}\n\nTable: Data summary\n\n|                         |      |\n|:------------------------|:-----|\n|Name                     |df_nz |\n|Number of rows           |60000 |\n|Number of columns        |130   |\n|_______________________  |      |\n|Column type frequency:   |      |\n|factor                   |6     |\n|numeric                  |124   |\n|________________________ |      |\n|Group variables          |None  |\n\n\n**Variable type: factor**\n\n|skim_variable                 | n_missing| complete_rate|ordered | n_unique|top_counts                                    |\n|:-----------------------------|---------:|-------------:|:-------|--------:|:---------------------------------------------|\n|id                            |         0|          1.00|FALSE   |    20000|1: 3, 2: 3, 3: 3, 4: 3                        |\n|wave                          |         0|          1.00|FALSE   |        3|201: 20000, 201: 20000, 202: 20000            |\n|gen_cohort                    |         0|          1.00|TRUE    |        5|gen: 24828, gen: 19965, gen: 11664, gen: 2280 |\n|eth_cat                       |       786|          0.99|FALSE   |        4|eur: 47556, mao: 6843, asi: 3321, pac: 1494   |\n|religion_bigger_denominations |     12562|          0.79|FALSE   |       11|not: 30926, chr: 5557, cat: 3632, ang: 2274   |\n|alert_level_combined_lead     |     20784|          0.65|FALSE   |        6|no_: 35035, ear: 1618, ale: 1274, ale: 670    |\n\n\n**Variable type: numeric**\n\n|skim_variable                                | n_missing| complete_rate|      mean|       sd|    p0|      p25|      p50|       p75|       p100|hist  |\n|:--------------------------------------------|---------:|-------------:|---------:|--------:|-----:|--------:|--------:|---------:|----------:|:-----|\n|male                                         |         0|          1.00|      0.37|     0.48|  0.00|     0.00|     0.00|      1.00|       1.00|▇▁▁▁▅ |\n|sample_frame                                 |         0|          1.00|      8.26|     2.86|  1.10|     6.90|    10.10|     10.10|      10.90|▁▁▁▂▇ |\n|sample_frame_opt_in                          |         0|          1.00|      0.03|     0.16|  0.00|     0.00|     0.00|      0.00|       1.00|▇▁▁▁▁ |\n|year_measured                                |         0|          1.00|      0.79|     0.42| -1.00|     1.00|     1.00|      1.00|       1.00|▁▁▂▁▇ |\n|rural_gch_2018_l                             |       578|          0.99|      1.66|     0.98|  1.00|     1.00|     1.00|      2.00|       5.00|▇▂▂▁▁ |\n|regc_2022_l                                  |       593|          0.99|      7.16|     5.07|  1.00|     2.00|     7.00|     13.00|      99.00|▇▁▁▁▁ |\n|nz_dep2018                                   |       596|          0.99|      4.79|     2.74|  1.00|     2.04|     4.95|      7.00|      10.00|▇▇▆▅▃ |\n|born_nz                                      |       702|          0.99|      0.78|     0.41|  0.00|     1.00|     1.00|      1.00|       1.00|▂▁▁▁▇ |\n|edu                                          |      1523|          0.97|      5.42|     2.69|  0.00|     3.00|     7.00|      7.00|      10.00|▃▃▃▇▂ |\n|nzsei_13_l                                   |      4500|          0.92|     54.57|    16.64| 10.00|    42.00|    56.00|     69.00|      90.00|▁▃▅▇▁ |\n|age                                          |     12229|          0.80|     50.96|    13.76| 18.12|    41.19|    53.35|     61.56|      97.90|▂▅▇▂▁ |\n|sample_weights                               |     12229|          0.80|      1.00|     1.27|  0.30|     0.48|     0.65|      0.93|      19.96|▇▁▁▁▁ |\n|sfhealth                                     |     12242|          0.80|      5.04|     1.17|  1.00|     4.34|     5.04|      5.96|       7.00|▁▂▃▇▅ |\n|perfectionism                                |     12247|          0.80|      3.12|     1.37|  1.00|     2.01|     3.00|      4.03|       7.00|▇▇▅▃▁ |\n|gratitude                                    |     12248|          0.80|      5.90|     0.88|  1.00|     5.34|     6.01|      6.65|       7.00|▁▁▁▅▇ |\n|forgiveness                                  |     12255|          0.80|      5.08|     1.27|  1.00|     4.31|     5.32|      6.02|       7.00|▁▂▃▇▇ |\n|vengeful_rumin                               |     12255|          0.80|      2.92|     1.27|  1.00|     1.98|     2.68|      3.68|       7.00|▇▇▃▂▁ |\n|lifemeaning                                  |     12261|          0.80|      5.45|     1.18|  1.00|     4.96|     5.53|      6.46|       7.00|▁▁▃▅▇ |\n|support                                      |     12268|          0.80|      5.94|     1.12|  1.00|     5.35|     6.29|      6.96|       7.00|▁▁▁▃▇ |\n|nwi                                          |     12306|          0.79|      5.30|     1.67|  0.00|     4.30|     5.33|      6.38|      10.00|▁▃▇▆▁ |\n|sfhealth_get_sick_easier_reversed            |     12344|          0.79|      5.67|     1.62|  1.00|     4.99|     6.02|      6.99|       7.00|▁▁▁▁▇ |\n|meaning_sense                                |     12380|          0.79|      5.72|     1.20|  1.00|     5.01|     5.99|      6.96|       7.00|▁▁▁▂▇ |\n|parent                                       |     12398|          0.79|      0.73|     0.45|  0.00|     0.00|     1.00|      1.00|       1.00|▃▁▁▁▇ |\n|self_control_wish_more_reversed              |     12398|          0.79|      3.73|     1.82|  1.00|     2.03|     3.04|      5.03|       7.00|▇▆▅▃▆ |\n|pwb_your_future_security                     |     12403|          0.79|      6.32|     2.35|  0.00|     4.98|     6.98|      8.01|      10.00|▂▃▆▇▆ |\n|emotion_regulation_hide_neg_emotions         |     12408|          0.79|      4.19|     1.66|  1.00|     2.99|     4.04|      5.05|       7.00|▆▅▆▇▇ |\n|pwb_your_health                              |     12442|          0.79|      6.68|     2.33|  0.00|     5.02|     7.02|      8.04|      10.00|▁▂▅▇▇ |\n|pwb_standard_living                          |     12457|          0.79|      7.68|     2.00|  0.00|     6.97|     8.00|      9.02|      10.00|▁▁▂▅▇ |\n|pwb_your_relationships                       |     12460|          0.79|      7.71|     2.26|  0.00|     6.97|     8.03|      9.03|      10.00|▁▁▂▃▇ |\n|neighbourhood_community                      |     12461|          0.79|      4.27|     1.63|  1.00|     3.00|     4.04|      5.95|       7.00|▆▅▆▇▇ |\n|power_no_control_composite                   |     12469|          0.79|      2.92|     1.41|  1.00|     1.96|     2.55|      3.99|       7.00|▇▅▆▂▁ |\n|power_no_control_composite_reversed          |     12469|          0.79|      5.08|     1.41|  1.00|     4.01|     5.45|      6.04|       7.00|▁▂▆▅▇ |\n|sfhealth_expect_worse_health_reversed        |     12478|          0.79|      4.12|     1.73|  1.00|     2.98|     4.00|      5.96|       7.00|▆▆▆▃▇ |\n|employed                                     |     12558|          0.79|      0.79|     0.41|  0.00|     1.00|     1.00|      1.00|       1.00|▂▁▁▁▇ |\n|religion_religious                           |     12561|          0.79|      0.35|     0.48|  0.00|     0.00|     0.00|      1.00|       1.00|▇▁▁▁▅ |\n|conscientiousness                            |     12616|          0.79|      5.12|     1.05|  1.00|     4.47|     5.24|      5.96|       7.00|▁▁▅▇▅ |\n|extraversion                                 |     12618|          0.79|      3.86|     1.19|  1.00|     3.01|     3.80|      4.72|       7.00|▂▆▇▅▁ |\n|openness                                     |     12622|          0.79|      4.96|     1.11|  1.00|     4.22|     5.00|      5.77|       7.00|▁▂▆▇▅ |\n|agreeableness                                |     12626|          0.79|      5.36|     0.99|  1.00|     4.74|     5.48|      6.03|       7.00|▁▁▃▇▆ |\n|belong                                       |     12626|          0.79|      5.11|     1.08|  1.00|     4.36|     5.30|      5.98|       7.00|▁▁▃▇▅ |\n|honesty_humility                             |     12627|          0.79|      5.50|     1.16|  1.00|     4.75|     5.72|      6.47|       7.00|▁▁▃▆▇ |\n|neuroticism                                  |     12628|          0.79|      3.48|     1.15|  1.00|     2.71|     3.47|      4.25|       7.00|▃▇▇▃▁ |\n|self_esteem                                  |     12633|          0.79|      5.14|     1.29|  1.00|     4.32|     5.34|      6.04|       7.00|▁▂▃▇▇ |\n|power_self_nocontrol                         |     12642|          0.79|      2.96|     1.64|  1.00|     1.96|     2.95|      4.02|       7.00|▇▂▂▂▂ |\n|kessler6_sum                                 |     12650|          0.79|      5.31|     4.11|  0.00|     2.03|     4.04|      7.04|      24.00|▇▆▂▁▁ |\n|kessler_latent_depression                    |     12654|          0.79|      0.58|     0.74|  0.00|     0.01|     0.32|      0.98|       4.00|▇▂▁▁▁ |\n|kessler_latent_anxiety                       |     12656|          0.79|      1.20|     0.77|  0.00|     0.66|     1.04|      1.68|       4.00|▇▇▆▁▁ |\n|lifesat                                      |     12666|          0.79|      5.29|     1.21|  1.00|     4.53|     5.50|      6.03|       7.00|▁▁▃▆▇ |\n|support_turnto                               |     12688|          0.79|      5.88|     1.28|  1.00|     5.03|     6.02|      6.99|       7.00|▁▁▁▂▇ |\n|emotion_regulation_out_control               |     12701|          0.79|      2.81|     1.66|  1.00|     1.04|     2.03|      4.01|       7.00|▇▂▂▂▁ |\n|modesty                                      |     12709|          0.79|      6.04|     0.92|  1.00|     5.50|     6.24|      6.79|       7.00|▁▁▁▃▇ |\n|pers_honestyhumility_seen_expensivecar       |     12737|          0.79|      5.66|     1.56|  1.00|     4.97|     6.02|      6.99|       7.00|▁▁▁▂▇ |\n|belong_beliefs                               |     12741|          0.79|      4.77|     1.28|  1.00|     3.99|     4.99|      5.98|       7.00|▂▂▆▇▇ |\n|hlth_weight                                  |     12742|          0.79|     79.29|    18.55| 35.03|    65.04|    77.00|     89.99|     209.99|▅▇▁▁▁ |\n|pers_honestyhumility_deserve_more            |     12743|          0.79|      5.30|     1.53|  1.00|     4.02|     5.97|      6.96|       7.00|▁▁▂▂▇ |\n|hlth_fatigue                                 |     12756|          0.79|      1.64|     1.07|  0.00|     0.98|     1.96|      2.04|       4.00|▃▇▇▃▁ |\n|kessler_depressed                            |     12765|          0.79|      0.47|     0.78|  0.00|     0.00|     0.02|      0.98|       4.00|▇▂▁▁▁ |\n|belong_routside_reversed                     |     12767|          0.79|      5.04|     1.74|  1.00|     3.97|     5.95|      6.96|       7.00|▂▂▂▂▇ |\n|pers_agreeable_sympathise_others             |     12767|          0.79|      5.64|     1.16|  1.00|     5.00|     5.98|      6.05|       7.00|▁▁▁▃▇ |\n|pers_honestyhumility_pleasure_expensivegoods |     12767|          0.79|      5.32|     1.66|  1.00|     4.01|     5.98|      6.97|       7.00|▁▂▂▂▇ |\n|bodysat                                      |     12768|          0.79|      4.23|     1.70|  1.00|     2.99|     4.04|      5.97|       7.00|▅▅▅▆▇ |\n|rumination                                   |     12768|          0.79|      0.83|     0.99|  0.00|     0.00|     0.95|      1.04|       4.00|▇▅▂▁▁ |\n|kessler_restless                             |     12779|          0.79|      1.22|     0.94|  0.00|     0.95|     1.02|      1.99|       4.00|▅▇▆▂▁ |\n|kessler_nervous                              |     12785|          0.79|      1.16|     0.94|  0.00|     0.04|     1.01|      1.98|       4.00|▆▇▅▂▁ |\n|kessler_worthless                            |     12788|          0.79|      0.50|     0.84|  0.00|     0.00|     0.02|      0.99|       4.00|▇▂▁▁▁ |\n|selfesteem_failure_reversed                  |     12791|          0.79|      5.23|     1.63|  1.00|     4.01|     5.97|      6.96|       7.00|▁▂▂▂▇ |\n|kessler_effort                               |     12794|          0.79|      1.23|     0.98|  0.00|     0.05|     1.01|      1.99|       4.00|▅▇▅▂▁ |\n|hlth_height                                  |     12795|          0.79|      1.70|     0.10|  1.26|     1.63|     1.69|      1.77|       2.10|▁▂▇▃▁ |\n|kessler_hopeless                             |     12797|          0.79|      0.78|     0.88|  0.00|     0.00|     0.96|      1.04|       4.00|▇▅▃▁▁ |\n|selfesteem_satself                           |     12797|          0.79|      5.13|     1.45|  1.00|     4.03|     5.95|      6.02|       7.00|▁▁▂▃▇ |\n|pers_conscientious_chores_done               |     12808|          0.79|      4.67|     1.50|  1.00|     3.96|     4.98|      5.99|       7.00|▂▃▅▆▇ |\n|pers_conscientious_forget_putback            |     12812|          0.79|      5.15|     1.65|  1.00|     4.00|     5.96|      6.04|       7.00|▂▂▂▂▇ |\n|belong_accept                                |     12814|          0.79|      5.52|     1.27|  1.00|     4.98|     5.98|      6.04|       7.00|▁▁▁▃▇ |\n|pers_agreeable_no_interest_others            |     12819|          0.79|      5.39|     1.36|  1.00|     4.96|     5.97|      6.04|       7.00|▁▁▂▃▇ |\n|pers_extraversion_talk_peopleparties         |     12820|          0.79|      3.81|     1.72|  1.00|     2.04|     3.98|      5.02|       7.00|▇▅▆▅▆ |\n|pers_extraversion_life_party                 |     12828|          0.79|      3.42|     1.44|  1.00|     2.03|     3.05|      4.04|       7.00|▇▆▇▅▂ |\n|selfesteem_postiveself                       |     12830|          0.79|      5.06|     1.41|  1.00|     4.02|     5.03|      6.01|       7.00|▁▂▃▅▇ |\n|pers_neuroticism_upset_easily                |     12843|          0.79|      3.47|     1.52|  1.00|     2.02|     3.03|      4.96|       7.00|▇▅▅▃▂ |\n|pers_neuroticism_mostly_relaxed              |     12844|          0.79|      3.43|     1.42|  1.00|     2.03|     3.03|      4.04|       7.00|▇▇▆▃▂ |\n|pers_neuroticism_mood_swings                 |     12847|          0.79|      3.15|     1.59|  1.00|     1.98|     2.99|      4.03|       7.00|▇▃▃▂▂ |\n|pers_neuroticism_seldom_blue                 |     12851|          0.79|      3.86|     1.66|  1.00|     2.04|     3.99|      5.02|       7.00|▇▅▆▆▆ |\n|pers_conscientious_like_order                |     12853|          0.79|      5.41|     1.29|  1.00|     4.96|     5.96|      6.04|       7.00|▁▁▂▃▇ |\n|pers_extraversion_keepbackground             |     12854|          0.79|      3.92|     1.49|  1.00|     2.98|     3.99|      5.00|       7.00|▆▆▇▆▅ |\n|pers_agreeable_feel_others_emotions          |     12859|          0.79|      5.32|     1.31|  1.00|     4.96|     5.96|      6.03|       7.00|▁▁▂▃▇ |\n|pers_agreeable_no_interest_others_probs      |     12870|          0.79|      5.07|     1.48|  1.00|     4.01|     5.04|      6.02|       7.00|▁▂▂▃▇ |\n|pers_honestyhumility_feel_entitled           |     12873|          0.79|      5.69|     1.32|  1.00|     4.99|     6.00|      6.97|       7.00|▁▁▁▂▇ |\n|pers_openness_vivid_imagination              |     12882|          0.79|      4.67|     1.52|  1.00|     3.96|     4.98|      5.99|       7.00|▂▃▅▆▇ |\n|pers_extraversion_dont_talkalot              |     12894|          0.79|      4.31|     1.59|  1.00|     3.01|     4.03|      5.96|       7.00|▅▅▇▆▇ |\n|pers_conscientious_make_mess                 |     12897|          0.79|      5.26|     1.37|  1.00|     4.03|     5.96|      6.03|       7.00|▁▁▂▃▇ |\n|pers_openness_good_imagination               |     12904|          0.78|      5.22|     1.55|  1.00|     4.02|     5.96|      6.04|       7.00|▁▂▂▃▇ |\n|lifesat_satlife                              |     12917|          0.78|      5.67|     1.23|  1.00|     5.00|     5.99|      6.95|       7.00|▁▁▁▂▇ |\n|pers_openness_difficult_abstraction          |     12918|          0.78|      4.95|     1.54|  1.00|     3.98|     5.02|      6.02|       7.00|▂▂▃▃▇ |\n|pers_openness_interested_abstraction         |     13013|          0.78|      5.00|     1.50|  1.00|     3.99|     5.02|      6.02|       7.00|▁▂▃▃▇ |\n|hlth_bmi                                     |     13016|          0.78|     27.41|     5.93| 12.35|    23.39|    26.26|     30.18|      75.56|▆▇▁▁▁ |\n|smoker                                       |     13077|          0.78|      0.06|     0.24|  0.00|     0.00|     0.00|      0.00|       1.00|▇▁▁▁▁ |\n|self_control_have_lots                       |     13107|          0.78|      5.04|     1.43|  1.00|     4.02|     5.03|      6.01|       7.00|▁▂▂▅▇ |\n|religion_identification_level                |     13120|          0.78|      2.33|     2.17|  1.00|     1.00|     1.00|      4.00|       7.00|▇▁▁▁▂ |\n|meaning_purpose                              |     13302|          0.78|      5.18|     1.43|  1.00|     4.04|     5.04|      6.03|       7.00|▁▁▂▅▇ |\n|support_help                                 |     13303|          0.78|      6.07|     1.16|  1.00|     5.96|     6.04|      7.00|       7.00|▁▁▁▁▇ |\n|partner                                      |     13333|          0.78|      0.76|     0.43|  0.00|     1.00|     1.00|      1.00|       1.00|▂▁▁▁▇ |\n|permeability_individual                      |     13371|          0.78|      5.20|     1.24|  1.00|     4.05|     5.03|      6.01|       7.00|▁▁▃▆▇ |\n|support_noguidance_reversed                  |     13373|          0.78|      5.88|     1.47|  1.00|     5.04|     6.04|      7.00|       7.00|▁▁▁▁▇ |\n|impermeability_group                         |     13408|          0.78|      3.67|     1.58|  1.00|     2.04|     3.97|      4.99|       7.00|▇▆▇▆▃ |\n|alcohol_frequency                            |     13462|          0.78|      2.17|     1.35|  0.00|     1.00|     2.02|      3.03|       5.00|▇▇▇▇▃ |\n|hours_charity                                |     13563|          0.77|      1.42|     4.18|  0.00|     0.00|     0.02|      0.99|     168.00|▇▁▁▁▁ |\n|hours_exercise                               |     13565|          0.77|      6.02|     7.80|  0.00|     2.00|     4.03|      7.02|     168.00|▇▁▁▁▁ |\n|religion_believe_god                         |     13809|          0.77|      0.44|     0.50|  0.00|     0.00|     0.00|      1.00|       1.00|▇▁▁▁▆ |\n|religion_believe_spirit                      |     13809|          0.77|      0.67|     0.47|  0.00|     0.00|     1.00|      1.00|       1.00|▃▁▁▁▇ |\n|sfhealth_your_health                         |     13942|          0.77|      5.33|     1.26|  1.00|     4.96|     5.96|      6.02|       7.00|▁▁▂▃▇ |\n|power_others_control                         |     14051|          0.77|      2.87|     1.61|  1.00|     1.95|     2.05|      4.01|       7.00|▇▂▂▂▁ |\n|emotion_regulation_change_thinking_to_calm   |     14177|          0.76|      4.81|     1.45|  1.00|     3.99|     5.00|      5.99|       7.00|▂▂▅▇▇ |\n|lifesat_ideal                                |     14186|          0.76|      4.89|     1.43|  1.00|     4.00|     5.01|      6.00|       7.00|▂▂▃▆▇ |\n|religion_perceive_religious_discrim          |     14198|          0.76|      1.96|     1.40|  1.00|     1.00|     1.04|      2.04|       7.00|▇▁▁▁▁ |\n|hlth_sleep_hours                             |     14277|          0.76|      6.94|     1.12|  2.00|     6.02|     7.00|      7.97|      20.00|▁▇▁▁▁ |\n|charity_donate                               |     14501|          0.76|   1013.80|  6682.04|  0.00|    20.03|   149.97|    500.02|  650000.00|▇▁▁▁▁ |\n|alcohol_intensity                            |     14605|          0.76|      2.08|     2.08|  0.00|     0.98|     1.97|      2.96|      36.00|▇▁▁▁▁ |\n|political_conservative                       |     14644|          0.76|      3.57|     1.37|  1.00|     2.05|     3.96|      4.04|       7.00|▆▅▇▃▂ |\n|household_inc                                |     14744|          0.75| 117927.50| 97598.66|  1.00| 59999.96| 99999.98| 150000.02| 3000000.00|▇▁▁▁▁ |\n|pol_wing                                     |     15139|          0.75|      3.71|     1.30|  1.00|     2.97|     3.98|      4.05|       7.00|▅▅▇▃▂ |\n|sexual_satisfaction                          |     15680|          0.74|      4.51|     1.77|  1.00|     3.04|     4.97|      6.00|       7.00|▃▂▅▅▇ |\n|emp_job_sat                                  |     23630|          0.61|      5.31|     1.45|  1.00|     4.96|     5.96|      6.04|       7.00|▁▁▂▃▇ |\n|emp_job_secure                               |     23677|          0.61|      5.49|     1.55|  1.00|     4.97|     5.99|      6.97|       7.00|▁▁▁▂▇ |\n|emp_job_valued                               |     23912|          0.60|      5.18|     1.65|  1.00|     4.02|     5.96|      6.05|       7.00|▂▁▂▃▇ |\n|home_owner                                   |     27754|          0.54|      0.76|     0.43|  0.00|     1.00|     1.00|      1.00|       1.00|▂▁▁▁▇ |\n\n\n:::\n\n```{.r .cell-code}\n# obtain ids for individuals who participated in 2018 and have no missing baseline exposure\nids_2018 <- df_nz |>\n  dplyr::filter(year_measured == 1, wave == 2018) |>\n  dplyr::filter(!is.na(!!sym(name_exposure))) |> # criteria, no missing\n  dplyr::filter(!is.na(eth_cat)) |> # criteria, no missing\n  pull(id)\n\n\n# obtain ids for individuals who participated in 2019\nids_2019 <- df_nz |>\n  dplyr::filter(year_measured == 1, wave == 2019) |>\n  dplyr::filter(!is.na(!!sym(name_exposure))) |> # criteria, no missing\n  pull(id)\n\n# intersect IDs from 2018 and 2019 to ensure participation in both years\nids_2018_2019 <- intersect(ids_2018, ids_2019)\n\n# data wrangling\ndat_long <- df_nz |>\n  dplyr::filter(id %in% ids_2018_2019 &\n                  wave %in% c(2018, 2019, 2020)) |>\n  arrange(id, wave) |>\n  select(\n    \"id\",\n    \"wave\",\n    \"year_measured\",\n    \"age\",\n    \"male\",\n    \"born_nz\",\n    \"eth_cat\",\n    #factor(EthCat, labels = c(\"Euro\", \"Maori\", \"Pacific\", \"Asian\")),\n    \"employed\",\n    # are you currently employed? (this includes self-employment or casual work)\n    \"edu\",\n    # \"gen_cohort\",\n    \"household_inc\",\n    \"partner\",\n    # 0 = no, 1 = yes\n    \"parent\",\n    #\"alert_level_combined_lead\", # see bibliography\n    # 0 = no, 1 = yes\n    \"political_conservative\", # see nzavs sheet\n    \"hours_exercise\", # see nzavs sheet\n    \"agreeableness\", \n    # Mini-IPIP6 Agreeableness (also modelled as empathy facet)\n    # Sympathize with others' feelings.\n    # Am not interested in other people's problems.\n    # Feel others' emotions.\n    # Am not really interested in others.\n    \"conscientiousness\",\n    # see mini ipip6\n    # Get chores done right away.\n    # Like order.\n    # Make a mess of things.\n    # Often forget to put things back in their proper place.\n    \"extraversion\",\n    # Mini-IPIP6 Extraversion\n    # Am the life of the party.\n    # Don't talk a lot.\n    # Keep in the background.\n    # Talk to a lot of different people at parties.\n    \"honesty_humility\",\n    # see mini ipip6\n    # Would like to be seen driving around in a very expensive car.\n    # Would get a lot of pleasure from owning expensive luxury goods.\n    # Feel entitled to more of everything.\n    # Deserve more things in life.\n    \"openness\",\n    # see mini ipip6\n    # Have a vivid imagination.\n    # Have difficulty understanding abstract ideas.\n    # Do not have a good imagination.\n    # Am not interested in abstract ideas.\n    \"neuroticism\",\n    # see mini ipip6\n    # Have frequent mood swings.\n    # Am relaxed most of the time.\n    # Get upset easily.\n    # Seldom feel blue.\n    \"modesty\",\n    # # see mini ipip6\n    # # I want people to know that I am an important person of high status,\n    # # I am an ordinary person who is no better than others.\n    # # I wouldn’t want people to treat me as though I were superior to them.\n    # # I think that I am entitled to more respect than the average person is\n    #\"w_gend_age_ethnic\",\n    \"neighbourhood_community\",\n    # #I feel a sense of community with others in my local neighbourhood.\n    \"belong\", # see nzavs sheet\n    \"rural_gch_2018_l\",# see nzavs sheet\n    \"support\",\n    # \"support_help\",\n    # # 'There are people I can depend on to help me if I really need it.\n    # \"support_turnto\",\n    # # There is no one I can turn to for guidance in times of stress.\n    # \"support_rnoguidance\",\n    #There is no one I can turn to for guidance in times of stress.\n    \"perfectionism\",\n    \"religion_religious\",\n    \"kessler_latent_depression\",\n    \"kessler_latent_anxiety\"\n  ) |>\n  mutate(\n    #initialize 'censored'\n    censored = ifelse(lead(year_measured) == 1, 1, 0),\n    \n    # modify 'censored' based on the condition; no need to check for NA here as 'censored' is already defined in the previous step\n    censored =  ifelse(is.na(censored) &\n                         year_measured == 1, 1, censored),\n    # create urban binary variable\n    \n    urban = ifelse(rural_gch_2018_l == 1, 1, 0)\n    \n  ) |>\n  select(-c(year_measured, rural_gch_2018_l) )|>\n  dplyr::mutate(\n    # rescale these variables, to get all variables on a similar scale\n    # otherwise your models can blow up, or become uninterpretable. \n    household_inc_log = log(household_inc + 1),\n    hours_exercise_log = log(hours_exercise + 1)  ) |>\n  dplyr::select(\n    -c(\n      household_inc,\n      hours_exercise)\n  ) |>\n  droplevels() |>\n  # dplyr::rename(sample_weights = w_gend_age_ethnic,\n  #               sample_origin =  sample_origin_names_combined) |>\n  arrange(id, wave) |>\n  mutate(\n    urban = as.numeric(as.character(urban)),\n    #   parent = as.numeric(as.character(parent)),\n    partner = as.numeric(as.character(partner)),\n    born_nz = as.numeric(as.character(born_nz)),\n    censored = as.numeric(as.character(censored)),\n    employed = as.numeric(as.character(employed))\n  ) |>\n  droplevels() |>\n  arrange(id, wave) |>\n  data.frame()\n\n\n# inspect data\nglimpse(dat_long)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRows: 42,990\nColumns: 29\n$ id                        <fct> 1, 1, 1, 3, 3, 3, 4, 4, 4, 5, 5, 5, 6, 6, 6,…\n$ wave                      <fct> 2018, 2019, 2020, 2018, 2019, 2020, 2018, 20…\n$ age                       <dbl> 40.31341, 41.33449, 42.24450, 47.14449, 47.9…\n$ male                      <dbl> 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0,…\n$ born_nz                   <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ eth_cat                   <fct> euro, euro, euro, maori, maori, maori, euro,…\n$ employed                  <dbl> 1, 1, 1, 0, 1, NA, 0, 0, 0, 1, 1, 0, 0, 1, 1…\n$ edu                       <dbl> 8, 8, 8, 3, 3, 3, 6, 6, 6, 6, 6, 6, 7, 7, 7,…\n$ partner                   <dbl> 1, 1, 1, 1, 1, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ parent                    <dbl> 1, 1, 1, 1, 1, NA, 1, 1, 1, 1, 1, 1, 1, 1, 1…\n$ political_conservative    <dbl> 1.000000, 1.022343, 1.042282, 3.021098, 3.02…\n$ agreeableness             <dbl> 6.235760, 6.216993, 6.539885, 4.997000, 4.54…\n$ conscientiousness         <dbl> 5.781907, 6.004211, 4.719577, 5.281236, 4.73…\n$ extraversion              <dbl> 4.740896, 4.737648, 4.724690, 2.752063, 3.23…\n$ honesty_humility          <dbl> 5.954770, 3.970874, 4.988354, 2.249136, 2.75…\n$ openness                  <dbl> 6.502722, 6.469405, 6.237941, 7.000000, 6.52…\n$ neuroticism               <dbl> 2.543777, 3.049655, 2.960180, 2.455489, 2.24…\n$ modesty                   <dbl> 6.786189, 6.002267, 5.702049, 5.239746, 4.74…\n$ neighbourhood_community   <dbl> 6.951882, 6.005449, 5.986452, 4.994146, 3.97…\n$ belong                    <dbl> 4.958810, 6.039168, 5.382137, 6.332741, 5.68…\n$ support                   <dbl> 7.000000, 6.959343, 6.967418, 6.983696, 7.00…\n$ perfectionism             <dbl> 4.303349, 3.670650, 3.337095, 2.660515, 3.33…\n$ religion_religious        <int> 0, 0, 0, 0, 0, NA, 1, 1, 1, 0, 0, 0, 0, 0, 0…\n$ kessler_latent_depression <dbl> 0.037011885, 0.000000000, 0.006337577, 0.000…\n$ kessler_latent_anxiety    <dbl> 0.96853714, 0.98302076, 1.71493734, 1.029461…\n$ censored                  <dbl> 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ urban                     <dbl> 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,…\n$ household_inc_log         <dbl> 12.206078, 12.206078, 11.849405, 11.532738, …\n$ hours_exercise_log        <dbl> 0.41844130, 0.01955105, 0.00000000, 3.219609…\n```\n\n\n:::\n\n```{.r .cell-code}\n# more thorough view\n#skimr::skim(dat_long)\n```\n:::\n\n\nNext let's insure that we obtain 50/50 representation of gender within our estimation.  \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# balance on gender weights\n# calculate gender weights assuming male is coded as 1 and female as 0\nprop_male_population <-\n  0.5  # target proportion of males in the population\nprop_female_population <-\n  0.5  # target proportion of females in the population\n\nprop_male_sample <- mean(dat_long$male)\nprop_female_sample <- 1 - prop_male_sample\n\ngender_weight_male <- prop_male_population / prop_male_sample\ngender_weight_female <- prop_female_population / prop_female_sample\n\ndat_long$sample_weights <-\n  ifelse(dat_long$male == 1, gender_weight_male, gender_weight_female)\n\n# we will upweight males and down weight non-males to obtain a balance of gender in the *target* population\ntable(dat_long$sample_weights)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n0.783745351126667  1.38107170393216 \n            27426             15564 \n```\n\n\n:::\n:::\nNext let's get our data into shape.  Today we're going to consider a 'treatment' of perfectionism in which we shift people by different quantiles of perfectionism: \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndat_long <-\n  margot::create_ordered_variable(dat_long, \"perfectionism\", n_divisions = 4) #\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n=== Creating Ordered Variable ===\nNote: ties.method set to last based on cutpoint_inclusive.\n\nVariable Summary:\n  Min value: 1 \n  Max value: 7 \n  Number of NA values: 2795 \n\nUsing quantile breaks:\n  Number of divisions: 4 \n  Breaks:\n\n\n|    Break|\n|--------:|\n| 1.000000|\n| 1.997943|\n| 2.986456|\n| 4.016010|\n| 7.000000|\n\nNew Variable Summary:\n  New column name: perfectionism_cat \n  Category distribution:\n\n\n|Category  | Count|\n|:---------|-----:|\n|[1.0,2.0] | 10049|\n|(2.0,3.0] | 10049|\n|(3.0,4.0] | 10049|\n|(4.0,7.0] | 10048|\n|NA        |  2795|\n\nOrdered variable created successfully 👍 \n================================================================================\n```\n\n\n:::\n\n```{.r .cell-code}\n# view scale\n# uncommentto see break points\n# print(quantile(dat_long$perfectionism, probs = seq(0, 1, 1/4), na.rm = TRUE))\n\n# n by groups\ntable(dat_long$perfectionism_cat)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n[1.0,2.0] (2.0,3.0] (3.0,4.0] (4.0,7.0] \n    10049     10049     10049     10048 \n```\n\n\n:::\n\n```{.r .cell-code}\n# obtain labels if useful later\nlabels <- levels(dat_long$perfectionism_cat)\n```\n:::\n\n\n\n\n### Consider where the quantiles break\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_19 <- dat_long |> filter(wave == 2019)\n\nmargot::margot_plot_categorical(col_name = \"perfectionism\",\n                                    # custom_breaks = c(1,1.9,3.9,7),\n                                    n_divisions = 4,\n                                     cutpoint_inclusive = \"upper\",\n                                     binwidth = .5,\n                                     dt_19)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\n=== Creating Ordered Variable ===\nNote: ties.method set to last based on cutpoint_inclusive.\n\nVariable Summary:\n  Min value: 1 \n  Max value: 7 \n  Number of NA values: 0 \n\nUsing quantile breaks:\n  Number of divisions: 4 \n  Breaks:\n\n\n|    Break|\n|--------:|\n| 1.000000|\n| 1.996297|\n| 2.985367|\n| 4.017218|\n| 7.000000|\n\nNew Variable Summary:\n  New column name: perfectionism_cat \n  Category distribution:\n\n\n|Category  | Count|\n|:---------|-----:|\n|[1.0,2.0] |  3583|\n|(2.0,3.0] |  3582|\n|(3.0,4.0] |  3583|\n|(4.0,7.0] |  3582|\n\nOrdered variable created successfully 👍 \n================================================================================\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](08-content_files/figure-html/unnamed-chunk-5-1.png){width=1152}\n:::\n:::\n\n\n### Consider mean\n\n::: {.cell}\n\n```{.r .cell-code}\ndt_19 <- dat_long |> filter(wave == 2019)\n\nmargot::coloured_histogram_sd(col_name = \"perfectionism\", binwidth = .5, dt_19)\n```\n\n::: {.cell-output-display}\n![](08-content_files/figure-html/unnamed-chunk-6-1.png){width=1152}\n:::\n\n```{.r .cell-code}\nmargot::margot_plot_shift(col_name = \"perfectionism\", binwidth = .1, \n                                 shift = \"down\",\n                                 range_highlight = c(1,2),\n                                 dt_19)\n```\n\n::: {.cell-output-display}\n![](08-content_files/figure-html/unnamed-chunk-6-2.png){width=1152}\n:::\n:::\n\n\n\n### Set variables\n\nNext lets set our baseline variables\n\n::: {.cell}\n\n```{.r .cell-code}\nbaseline_vars = c(\"age\", \"male\", \"edu\", \"eth_cat\", \"partner\", \"employed\", \"born_nz\", \"neighbourhood_community\", \"household_inc_log\", \"parent\", \"religion_religious\", \"urban\", \"employed\", \"sample_weights\")\n\n# treatment\nexposure_vars = c(\"perfectionism_cat\") \n\n# outcome, can be many\noutcome_vars = c(\"kessler_latent_anxiety\", \"kessler_latent_depression\")\n```\n:::\n\n\n\n\n### Muliply impute missing values\n\n\nIn our first analysis we will not merely impute baseline values. Rather we will impute baseline and outcome values within quantiles of the exposure.  Consider, why should we impute within the treatments to be compared?  What are the lingering dangers of this approach? \n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# make long data wide\n\n# remove sample weights, return them later\nprep_dat_wide <- margot_wide(dat_long, \n                             baseline_vars = baseline_vars, \n                             exposure_var = exposure_vars,\n                             outcome_vars = outcome_vars)\n\n\n# filter data, so that we impute within quartiles\nlist_filtered_df <-\n  margot::margot_filter(prep_dat_wide, exposure_vars = \"t1_perfectionism_cat\", sort_var = \"id\")\n\n# check that these add up to the total data set\na <- nrow( list_filtered_df$tile_1)\nb <- nrow( list_filtered_df$tile_2)\nc <- nrow( list_filtered_df$tile_3)\nd <-nrow( list_filtered_df$tile_4)\n\n# must sum to equal\na + b + c + d == nrow(prep_dat_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nlogical(0)\n```\n\n\n:::\n:::\n\n\n### Visualise missing values\n\n::: {.cell}\n\n```{.r .cell-code}\n# visually inspect missingness\nnaniar::vis_miss(prep_dat_wide, warn_large_data = FALSE)\n```\n\n::: {.cell-output-display}\n![](08-content_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n\n```{.r .cell-code}\n# check for collinear vars\nmice:::find.collinear(prep_dat_wide) # note sample weights is collinear\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"t0_sample_weights\"\n```\n\n\n:::\n:::\n\n\n### Imputations\nNext we impute by quartile.  Save this output in your folder. \n\n::: {.cell}\n\n```{.r .cell-code}\n# impute by quartile\nmice_health <- margot::impute_and_combine(list_filtered_df,  m = 5 )\n\n\nmargot::here_save(mice_health, \"mice_health\")\n```\n:::\n\n\n### Wrangling\n\n::: {.cell}\n\n```{.r .cell-code}\n# read data if you are not running the imputation again\nmice_health <- here_read(\"mice_health\")\n\n# post-imputation arrange\nmice_health_mids <- mice_health |>\n  arrange(.imp, id) |>\n  rename(sample_weights = t0_sample_weights) |>\ndplyr::mutate(\n  across(\n    where(is.numeric) &\n      !sample_weights,\n    ~ scale(.x),\n    .names = \"{col}_z\"\n  )\n) |>\n  select(-.imp_z, -.id_z) |>\n  select(where(is.factor),\n         sample_weights,\n         ends_with(\"_z\"),\n         .imp,\n         .id) |>\n  relocate(sample_weights, .before = starts_with(\"t1_\"))  |>\n  relocate(id, .before = sample_weights)  |>\n  relocate(starts_with(\"t0_\"), .before = starts_with(\"t1_\"))  |>\n  relocate(starts_with(\"t2_\"), .after = starts_with(\"t1_\"))  |>\n  arrange(.imp, id) |>\n  droplevels() |>\n  mutate_if(is.matrix, as.vector) |>\n  as.mids()\n\n# make long\nmice_health_long <- mice::complete(mice_health_mids, \"long\", inc = TRUE)\n\n\n#Save\nhere_save(mice_health_mids, \"mice_health_mids\")\nhere_save(mice_health_long, \"mice_health_long\")\n```\n:::\n\n### Compute propensity scores for IPTW using machine learning\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# this is how you read saved files without the margot package\nmice_health_mids <- readRDS(here::here(push_mods, \"mice_health_mids\"))\nmice_health_long <- readRDS(here::here(push_mods, \"mice_health_long\"))\n\n# propensity scors --------------------------------------------------------\n\n\n# set exposure\nX = \"t1_perfectionism_cat\"\n\n# set estimand\nestimand = \"ATE\"\n\n# set baseline variables\nbaseline_vars_models = mice_health_long |>\n  dplyr::select(starts_with(\"t0\"))|> colnames() # note, we earlier change name of `t0_sample_weights` to `sample weights`\n\nbaseline_vars_models\n# obtain propensity scores\nmatch_ebal_ate <- margot::match_mi_general(data = mice_health_mids, \n                                      X = X, \n                                      baseline_vars = baseline_vars_models, \n                                      estimand = \"ATE\",  \n                                   #   focal = \"tile_3\", #for ATT\n                                      method = \"ebal\", \n                                      sample_weights = \"sample_weights\")\n\n# save output\nmargot::here_save(match_ebal_ate, \"match_ebal_ate\")\n```\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# read output\nmatch_ebal_ate <- margot::here_read(\"match_ebal_ate\")\n\n\n# check balance\n#bal.tab(match_ebal_ate)\n\n# visualise imbalance\nlove.plot(match_ebal_ate, binary = \"std\", thresholds = c(m = .1),\n          wrap = 50, position = \"bottom\", size =3)\n```\n:::\n\n### Visualise imbalance\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# consider results \n\nsum_ebal_match_ebal_ate <- summary(match_ebal_ate)\n\n# summarise\nsum_ebal_match_ebal_ate\n\n# visualise\nplot(sum_ebal_match_ebal_ate)\n```\n:::\n\nSome extreme weights.  We can trim weights as follows. (Note there is no hard and fast rule about how much to trim weights by, here we trim by 1%.)\n\n::: {.cell}\n\n```{.r .cell-code}\n# trimmed weights\nmatch_ebal_ate_trim <- WeightIt::trim(match_ebal_ate, at = .99)\n\n# check balance\n# bal.tab(match_ebal_ate_trim)\n\n# summary\nsummary_match_ebal_ate_trim <- summary(match_ebal_ate_trim)\n\n# check - extreme weights gone\nplot(summary_match_ebal_ate_trim)\n\n# plot for balance\nlove.plot(match_ebal_ate_trim, binary = \"std\", thresholds = c(m = .1),\n          wrap = 50, position = \"bottom\", size =2, limits = list(m = c(-.5, .5)))\n```\n:::\n\n### Estimation\n\n::: {.cell}\n\n```{.r .cell-code}\n# here_save(match_ebal_ate_trim, \"match_ebal_ate_trim\")\n# match_ebal_ate_trim <- here_read( \"match_ebal_ate_trim\")\n\n# set data frame; output of match_mi_general model\ndf_ate = match_ebal_ate_trim\nstr(df_ate)\nstr(match_ebal_ate_trim)\n# remind self of levels if needed\n# levels(mice_health_long$t1_perfectionism_4tile)\n\n# set treatment level\ntreat_0 = \"[1.0,2.0]\" # lowest quartile\ntreat_1 = \"(4.0,7.0]\" # third quartile\n\n# bootstrap simulations ( generally use 1000)\nnsims <- 1000\n\n# cores\ncl =  parallel::detectCores () \n\nestimand = \"ATE\"\n\n# as specified\nvcov = \"HC2\" # robust standard errors. \n\n# cores\ncores = parallel::detectCores () # use all course\n\n# Example call to the function\n# propensity score only model\n\n# code review: these are the functions 'under the hood'\n\n# this function is defined outside of both main functions\n# build_formula_str <- function(Y, X, continuous_X, splines, baseline_vars) {\n#   baseline_part <- if (!(length(baseline_vars) == 1 && baseline_vars == \"1\")) {\n#     paste(baseline_vars, collapse = \"+\")\n#   } else {\n#     \"1\"\n#   }\n# \n#   if (continuous_X && splines) {\n#     paste(Y, \"~ bs(\", X, \")\", \"*\", \"(\", baseline_part, \")\")\n#   } else {\n#     paste(Y, \"~\", X, \"*\", \"(\", baseline_part, \")\")\n#   }\n# }\n# \n# causal_contrast_marginal <- function(df, Y, X, baseline_vars = \"1\", treat_0, treat_1,\n#                                      estimand = c(\"ATE\", \"ATT\"), type = c(\"RR\", \"RD\"),\n#                                      nsims = 200, cores = parallel::detectCores(), family = \"gaussian\",\n#                                      weights = NULL, continuous_X = FALSE, splines = FALSE, vcov = \"HC2\",\n#                                      verbose = FALSE) {\n#   # validate the type argument\n#   type <- match.arg(type, choices = c(\"RR\", \"RD\"))\n# \n#   # validate the family argument\n#   if (is.character(family)) {\n#     if (!family %in% c(\"gaussian\", \"binomial\", \"Gamma\", \"inverse.gaussian\", \"poisson\", \"quasibinomial\", \"quasipoisson\", \"quasi\")) {\n#       stop(\"Invalid 'family' argument. Please specify a valid family function.\")\n#     }\n#     family_fun <- get(family, mode = \"function\", envir = parent.frame())\n#   } else if (inherits(family, \"family\")) {\n#     family_fun <- family\n#   } else {\n#     stop(\"Invalid 'family' argument. Please specify a valid family function or character string.\")\n#   }\n# \n#   # use the updated causal_contrast_engine function\n#   results <- causal_contrast_engine(\n#     df = df,\n#     Y = Y,\n#     X = X,\n#     baseline_vars = baseline_vars,\n#     treat_0 = treat_0,\n#     treat_1 = treat_1,\n#     estimand = estimand,\n#     type = type,\n#     nsims = nsims,\n#     cores = cores,\n#     family = family,\n#     weights = weights,\n#     continuous_X = continuous_X,\n#     splines = splines,\n#     vcov = vcov,\n#     verbose = verbose\n#   )\n# \n#   return(results)\n# }\n# \n# causal_contrast_engine <- function(df, Y, X, baseline_vars, treat_0, treat_1,\n#                                    estimand = c(\"ATE\", \"ATT\"), type = c(\"RR\", \"RD\"),\n#                                    nsims = 200, cores = parallel::detectCores(),\n#                                    family = \"gaussian\", weights = TRUE,\n#                                    continuous_X = FALSE, splines = FALSE,\n#                                    vcov = \"HC2\", verbose = FALSE) {\n#   # check if required packages are installed\n#   required_packages <- c(\"clarify\", \"rlang\", \"glue\", \"parallel\", \"mice\")\n#   for (pkg in required_packages) {\n#     if (!requireNamespace(pkg, quietly = TRUE)) {\n#       stop(paste0(\"Package '\", pkg, \"' is needed for this function but is not installed\"))\n#     }\n#   }\n# \n#   # helper function to process a single imputed dataset\n#   process_imputation <- function(imputed_data, weights) {\n#     # build formula\n#     formula_str <- build_formula_str(Y, X, continuous_X, splines, baseline_vars)\n#     \n#     # apply model\n#     fit <- glm(\n#       as.formula(formula_str),\n#       weights = weights,\n#       family = get(family, mode = \"function\", envir = parent.frame()),\n#       data = imputed_data\n#     )\n#     \n#     return(fit)\n#   }\n# \n#   # check if df is a wimids object\n#   if (inherits(df, \"wimids\")) {\n#     # Extract the mids object and weights\n#     mids_obj <- df$object\n#     weights_list <- lapply(df$models, function(m) m$weights)\n#     \n#     # process each imputed dataset\n#     fits <- lapply(1:mids_obj$m, function(i) {\n#       imputed_data <- mice::complete(mids_obj, i)\n#       process_imputation(imputed_data, weights_list[[i]])\n#     })\n#     \n#     # create a misim object\n#     sim.imp <- clarify::misim(fits, n = nsims, vcov = vcov)\n#   } else {\n#     # If df is not a wimids object, process it as before\n#     weight_var <- if (!is.null(weights) && weights %in% names(df)) df[[weights]] else NULL\n#     \n#     fit <- process_imputation(df, weight_var)\n#     sim.imp <- clarify::sim(fit, n = nsims, vcov = vcov)\n#   }\n# \n#   if (continuous_X) {\n#     estimand <- \"ATE\"\n#   }\n# \n#   # compute the average marginal effects\n#   if (!continuous_X && estimand == \"ATT\") {\n#     subset_expr <- rlang::expr(!!rlang::sym(X) == !!treat_1)\n#     sim_estimand <- clarify::sim_ame(\n#       sim.imp,\n#       var = X,\n#       subset = eval(subset_expr),\n#       cl = cores,\n#       verbose = FALSE\n#     )\n#   } else {\n#     sim_estimand <- clarify::sim_ame(sim.imp,\n#       var = X,\n#       cl = cores,\n#       verbose = FALSE\n#     )\n# \n#     treat_0_name <- paste0(\"`E[Y(\", treat_0, \")]`\")\n#     treat_1_name <- paste0(\"`E[Y(\", treat_1, \")]`\")\n# \n#     if (type == \"RR\") {\n#       rr_expression_str <- glue::glue(\"{treat_1_name}/{treat_0_name}\")\n#       rr_expression <- rlang::parse_expr(rr_expression_str)\n#       sim_estimand <- transform(sim_estimand, RR = eval(rr_expression))\n#       return(summary(sim_estimand))\n#     } else if (type == \"RD\") {\n#       rd_expression_str <- glue::glue(\"{treat_1_name} - {treat_0_name}\")\n#       rd_expression <- rlang::parse_expr(rd_expression_str)\n#       sim_estimand <- transform(sim_estimand, RD = eval(rd_expression))\n#       return(summary(sim_estimand))\n#     } else {\n#       stop(\"Invalid type. Please choose 'RR' or 'RD'\")\n#     }\n#   }\n# }\n\npropensity_mod_fit_t2_kessler_latent_anxiety_z <-double_robust_marginal(\n  df = df_ate,\n  Y = \"t2_kessler_latent_anxiety_z\",\n  X = X, \n  baseline_vars = 1, # we are not regressing with any covariates\n  treat_1 = treat_1,\n  treat_0 = treat_0,\n  nsims = 1000,\n  cores = cores,\n  family = \"gaussian\",\n  weights = TRUE,\n  continuous_X = FALSE,\n  splines = FALSE,\n  estimand = \"ATE\",\n  type_causal = \"RD\",  \n  type_tab = \"RD\",    \n  vcov = vcov,         \n  new_name = \"Kessler Anxiety (PR)\",\n  delta = 1,\n  sd = 1\n)\n\n\n\n# save\nhere_save(propensity_mod_fit_t2_kessler_latent_anxiety_z, \"propensity_mod_fit_t2_kessler_latent_anxiety_z\")\n\npropensity_mod_fit_t2_kessler_latent_depression_z <-margot::double_robust_marginal(\n  df = df_ate,\n  Y = \"t2_kessler_latent_depression_z\",\n  X = X,  \n  baseline_vars = 1, #no covariates, only the propensity scores\n  treat_1 = treat_1,\n  treat_0 = treat_0,\n  nsims = 1000,\n  cores = cores,\n  family = \"gaussian\",\n  weights = TRUE,\n  continuous_X = FALSE,\n  splines = FALSE,\n  estimand = \"ATE\",\n  type_causal = \"RD\",  \n  type_tab = \"RD\",    \n  vcov = vcov,         \n  new_name = \"Kessler Depression (PR)\",\n  delta = 1,\n  sd = 1\n)\n\n# save\nhere_save(propensity_mod_fit_t2_kessler_latent_depression_z, \"propensity_mod_fit_t2_kessler_latent_depression_z\")\n\n\n\n## Doubly robust\nmod_fit_t2_kessler_latent_anxiety_z <-margot::double_robust_marginal(\n  df = df_ate,\n  Y = \"t2_kessler_latent_anxiety_z\",\n  X = X,\n  baseline_vars = baseline_vars_models, # no covariates, only the propensity scores\n  treat_1 = treat_1,\n  treat_0 = treat_0,\n  nsims = 1000,\n  cores = cores,\n  family = \"gaussian\",\n  weights = TRUE,\n  continuous_X = FALSE,\n  splines = FALSE,\n  estimand = \"ATE\",\n  type_causal = \"RD\",  \n  type_tab = \"RD\",    \n  vcov = vcov,         \n  new_name = \"Kessler Anxiety (DR)\",\n  delta = 1,\n  sd = 1\n)\n# save\nhere_save(mod_fit_t2_kessler_latent_anxiety_z, \"mod_fit_t2_kessler_latent_anxiety_z\")\n\n\n# model 2\nmod_fit_t2_kessler_latent_depression_z <-margot::double_robust_marginal(\n  df = df_ate,\n  Y = \"t2_kessler_latent_depression_z\",\n  X = X,\n  baseline_vars = baseline_vars_models,\n  treat_1 = treat_1,\n  treat_0 = treat_0,\n  nsims = 1000,\n  cores = cores,\n  family = \"gaussian\",\n  weights = TRUE,\n  continuous_X = FALSE,\n  splines = FALSE,\n  estimand = \"ATE\",\n  type_causal = \"RD\",  \n  type_tab = \"RD\",    \n  vcov = vcov,         \n  new_name = \"Kessler Depression (DR)\",\n  delta = 1,\n  sd = 1\n)\n\n# save\nhere_save(mod_fit_t2_kessler_latent_depression_z, \"mod_fit_t2_kessler_latent_depression_z\")\n```\n:::\n\n\n### Results\n\n::: {.cell}\n\n```{.r .cell-code}\n# to save time, we do not run the models\n# recover saved models \n\n# propensity score  models\npropensity_mod_fit_t2_kessler_latent_depression_z<- here_read(\"propensity_mod_fit_t2_kessler_latent_depression_z\")\npropensity_mod_fit_t2_kessler_latent_anxiety_z<- here_read(\"propensity_mod_fit_t2_kessler_latent_anxiety_z\")\n\n# doubly robust models\nmod_fit_t2_kessler_latent_depression_z<- here_read(\"mod_fit_t2_kessler_latent_depression_z\")\nmod_fit_t2_kessler_latent_anxiety_z<- here_read(\"mod_fit_t2_kessler_latent_anxiety_z\")\n\n\n# tables\nlibrary(kableExtra)\n\n# proprensity only \ntab_double_pr <- rbind(propensity_mod_fit_t2_kessler_latent_depression_z$tab_results,\n      propensity_mod_fit_t2_kessler_latent_anxiety_z$tab_results)\n# bind results in a table\ntab_double_robust <- rbind(mod_fit_t2_kessler_latent_depression_z$tab_results,\n      mod_fit_t2_kessler_latent_anxiety_z$tab_results)\n\n\n# combine the individual results\ntab_combo <- rbind(tab_double_pr,tab_double_robust)\n\n\n# table\ntab_combo |> \n  kbl(format = \"markdown\")\n```\n:::\n\n\nWe see that the doubly robust estimator leads to lower overall effect sizes.\n\n<!-- ## Sugroup Estimation Using Machine Learning -->\n\n<!-- ### impute baseline values only -->\n\n<!-- ```{r} -->\n<!-- #| eval: false -->\n<!-- #| echo: true -->\n<!-- #| label: impute_subgroup_baseline -->\n<!-- # let's take a different approach -->\n<!-- # this time we include the censored variable  -->\n\n<!-- exposure_vars <- c(\"perfectionism_cat\", \"censored\") -->\n<!-- baseline_vars<-setdiff(baseline_vars, \"sample_weights\") -->\n\n<!-- # here we imput the baseline  -->\n<!-- df_impute_base<- margot_wide_impute_baseline(dat_long, baseline_vars = baseline_vars,  -->\n<!--                                              exposure_var = exposure_vars, outcome_vars = outcome_vars) -->\n\n<!-- # save -->\n\n<!-- # get sample weights -->\n<!-- dt_18 <- dat_long |> filter(wave == 2018) -->\n\n<!-- # add sample weights -->\n<!-- df_impute_base$t0_sample_weights = dt_18$sample_weights -->\n\n<!-- # save -->\n<!-- here_save(df_impute_base, \"df_impute_base\") -->\n<!-- ``` -->\n\n<!-- ### Obtain censoring weights -->\n\n\n<!-- ```{r} -->\n<!-- #| eval: false -->\n<!-- #| echo: true -->\n<!-- df_impute_base <- here_read(\"df_impute_base\") -->\n<!-- #  -->\n<!-- # # is.factor(df_impute_base$t0_perfectionism_cat) -->\n<!-- # # get correct censoring  -->\n<!-- # t0_na_condition <- -->\n<!-- #   rowSums(is.na(select(df_impute_base, starts_with(\"t1_\")))) > 0 -->\n<!-- # t1_na_condition <- -->\n<!-- #   rowSums(is.na(select(df_impute_base, starts_with(\"t2_\")))) > 0 -->\n<!-- #  -->\n<!-- # str(df_impute_base$t1_perfectionism_cat) -->\n<!-- #  -->\n<!-- #  -->\n<!-- #  -->\n<!-- # # Revised data cleaning code -->\n<!-- # df_clean <- df_impute_base |> -->\n<!-- #   mutate(t0_censored = ifelse(t0_na_condition, 0, t0_censored)) |> -->\n<!-- #   mutate(t1_censored = ifelse(t1_na_condition, 0, t1_censored)) |> -->\n<!-- #   mutate(across(starts_with(\"t1_\"), ~ ifelse(t0_censored == 0, NA, .)), -->\n<!-- #          across(starts_with(\"t2_\"), ~ ifelse(t0_censored == 0, NA, .))) |> -->\n<!-- #   mutate(across(starts_with(\"t2_\"), ~ ifelse(t1_censored == 0, NA, .))) |> -->\n<!-- #   # Scale numeric variables, excluding t1_perfectionism_cat -->\n<!-- #   mutate(across(where(is.numeric) &  -->\n<!-- #                 !any_of(c(\"t0_censored\", \"t0_sample_weights\", \"t1_censored\", \"t1_perfectionism_cat\")),  -->\n<!-- #                 ~ scale(.),  -->\n<!-- #                 .names = \"{.col}_z\")) |> -->\n<!-- #   # Ensure t1_perfectionism_cat remains a factor -->\n<!-- #   mutate(t1_perfectionism_cat = factor(t1_perfectionism_cat,  -->\n<!-- #                                        levels = levels(df_impute_base$t1_perfectionism_cat), -->\n<!-- #                                        ordered = TRUE)) |> -->\n<!-- #   select( -->\n<!-- #     where(is.factor), -->\n<!-- #     t0_sample_weights, -->\n<!-- #     t0_censored, -->\n<!-- #     t1_perfectionism_cat, -->\n<!-- #     t1_censored, -->\n<!-- #     ends_with(\"_z\") -->\n<!-- #   ) |> -->\n<!-- #   mutate(t0_lost = 1 - t1_censored, -->\n<!-- #          t1_lost = 1 - t1_censored) |>  -->\n<!-- #   relocate(starts_with(\"t0_\"), .before = starts_with(\"t1_\")) |> -->\n<!-- #   relocate(\"t0_censored\", .before = starts_with(\"t1_\")) |> -->\n<!-- #   relocate(\"t1_censored\", .before = starts_with(\"t2_\")) -->\n<!-- #  -->\n<!-- # # Check the result -->\n<!-- # print(str(df_clean$t1_perfectionism_cat)) -->\n<!-- # print(levels(df_clean$t1_perfectionism_cat)) -->\n<!-- # str(df_clean$t1_perfectionism_cat) -->\n\n<!-- # Get correct not_censored conditions -->\n<!-- t0_na_condition <- rowSums(is.na(select(df_impute_base, starts_with(\"t1_\")))) > 0 -->\n<!-- t1_na_condition <- rowSums(is.na(select(df_impute_base, starts_with(\"t2_\")))) > 0 -->\n\n<!-- # Revised data cleaning code -->\n<!-- df_clean <- df_impute_base |> -->\n<!--   mutate(t0_not_censored = ifelse(t0_na_condition, 0, 1), -->\n<!--          t1_not_censored = ifelse(t1_na_condition, 0, 1)) -->\n\n<!-- print(\"t0_not_censored and t1_not_censored after initial mutation:\") -->\n<!-- print(table(df_clean$t0_not_censored, df_clean$t1_not_censored)) -->\n\n<!-- df_clean <- df_clean |> -->\n<!--   # Apply NA conditions while preserving factor structure -->\n<!--   mutate(across(starts_with(\"t1_\") & !all_of(\"t1_perfectionism_cat\"),  -->\n<!--                 ~ ifelse(t0_not_censored == 0, NA, .))) |> -->\n<!--   mutate(across(starts_with(\"t2_\"),  -->\n<!--                 ~ ifelse(t1_not_censored == 0, NA, .))) |> -->\n<!--   # Scale numeric variables, excluding t1_perfectionism_cat -->\n<!--   mutate(across(where(is.numeric) &  -->\n<!--                 !any_of(c(\"t0_not_censored\", \"t0_sample_weights\", \"t1_not_censored\", \"t1_perfectionism_cat\")),  -->\n<!--                 ~ scale(.),  -->\n<!--                 .names = \"{.col}_z\")) |> -->\n<!--   # Ensure t1_perfectionism_cat remains a factor and apply t1_not_censored condition -->\n<!--   mutate(t1_perfectionism_cat = factor(t1_perfectionism_cat,  -->\n<!--                                        levels = levels(df_impute_base$t1_perfectionism_cat), -->\n<!--                                        ordered = TRUE), -->\n<!--          t1_perfectionism_cat = if_else(t1_not_censored == 0, NA_character_, as.character(t1_perfectionism_cat)), -->\n<!--          t1_perfectionism_cat = factor(t1_perfectionism_cat,  -->\n<!--                                        levels = levels(df_impute_base$t1_perfectionism_cat), -->\n<!--                                        ordered = TRUE)) -->\n\n<!-- print(\"t1_perfectionism_cat after applying conditions:\") -->\n<!-- print(table(df_clean$t1_perfectionism_cat, useNA = \"ifany\")) -->\n\n<!-- df_clean <- df_clean |> -->\n<!--   select( -->\n<!--     where(is.factor), -->\n<!--     t0_sample_weights, -->\n<!--     t0_not_censored, -->\n<!--     t1_perfectionism_cat, -->\n<!--     t1_not_censored, -->\n<!--     ends_with(\"_z\") -->\n<!--   ) |> -->\n<!--   mutate(t0_lost = 1 - t1_not_censored, -->\n<!--          t1_lost = 1 - t1_not_censored) |>  -->\n<!--   relocate(starts_with(\"t0_\"), .before = starts_with(\"t1_\")) |> -->\n<!--   relocate(\"t0_not_censored\", .before = starts_with(\"t1_\")) |> -->\n<!--   relocate(\"t1_not_censored\", .before = starts_with(\"t2_\")) -->\n\n<!-- # final checks -->\n<!-- print(\"Final t0_not_censored and t1_not_censored:\") -->\n<!-- print(table(df_clean$t0_not_censored, df_clean$t1_not_censored)) -->\n\n<!-- print(\"Final t1_perfectionism_cat:\") -->\n<!-- print(table(df_clean$t1_perfectionism_cat, useNA = \"ifany\")) -->\n\n<!-- print(\"Relationship between t1_not_censored and t1_perfectionism_cat:\") -->\n<!-- print(table(df_clean$t1_not_censored, is.na(df_clean$t1_perfectionism_cat))) -->\n\n\n<!-- # get rid of attributes -->\n<!-- df_clean <- margot::remove_numeric_attributes(df_clean) -->\n\n\n<!-- # censoring --------------------------------------------------------------- -->\n<!-- baseline_vars_models_ml = df_clean |>  # post process of impute and combine -->\n<!--   dplyr::select(starts_with(\"t0\"), -t0_not_censored, -t0_lost, -t0_sample_weights)|> colnames() # note, we ear -->\n\n<!-- baseline_vars_models_ml -->\n<!-- # fit proponsity score model  -->\n<!-- # match_censoring <- margot::match_mi_general(data = df_clean,  -->\n<!-- #                                       X = \"t1_lost\",  -->\n<!-- #                                       baseline_vars = baseline_vars_models,  -->\n<!-- #                                       estimand = \"ATE\",   -->\n<!-- #                                       # focal = \"< >\", for ATT -->\n<!-- #                                       method = \"cbps\",  -->\n<!-- #                                       sample_weights = \"sample_weights\") -->\n<!-- #  -->\n<!-- # # save output -->\n<!-- # here_save( match_censoring, \"match_censoring\")  # another approach -->\n\n\n\n<!-- df_clean_pre <- df_clean[baseline_vars_models_ml] -->\n<!-- # colnames(df_clean_pre) -->\n<!-- # Perform one-hot encoding using model.matrix -->\n<!-- encoded_vars <- model.matrix(~  t0_perfectionism_cat + t0_eth_cat - 1, data = df_clean_pre) -->\n\n<!-- # convert matrix to data frame -->\n<!-- encoded_df <- as.data.frame(encoded_vars) -->\n\n\n<!-- # make better names (if needed) -->\n<!-- encoded_df <- encoded_df |> -->\n<!--   janitor::clean_names() -->\n\n<!-- # View the first few rows to confirm structure -->\n<!-- head(encoded_df) -->\n\n<!-- # bind the new one-hot encoded variables back to the original dataframe -->\n<!-- # ensure to remove original categorical variables to avoid duplication -->\n<!-- df_clean_hot <- df_clean |> -->\n<!--   select(-c(t0_eth_cat,t0_perfectionism_cat)) |> -->\n<!--   bind_cols(encoded_df) -->\n\n<!-- # extract and print the new column names for encoded variables -->\n<!-- new_encoded_colnames <- colnames(encoded_df) -->\n<!-- print(new_encoded_colnames) -->\n\n<!-- new_encoded_colnames -->\n\n<!-- colnames(df_clean_pre) -->\n\n<!-- # assuming you have a base list of predictors -->\n<!-- baseline_vars_set <- setdiff(names(df_clean_pre), c(\"t0_lost\", \"t0_eth_cat\", \"t0_perfectionism_cat\")) -->\n<!-- baseline_vars_set -->\n<!-- # Add the new encoded column names -->\n<!-- full_predictor_vars <- c(baseline_vars_set, new_encoded_colnames) -->\n\n\n<!-- # check -->\n<!-- full_predictor_vars -->\n\n<!-- # cross validated sets -->\n<!-- cv_control <- list(V = 10, stratifyCV = TRUE)  # 10-fold CV with stratification -->\n\n<!-- # use super learner -->\n<!-- library(SuperLearner) -->\n<!-- library(ranger) -->\n\n<!-- # Multi core -->\n<!-- library(doParallel) -->\n<!-- library(SuperLearner) -->\n\n<!-- # check predictors -->\n<!-- str(df_clean_hot[full_predictor_vars]) -->\n\n<!-- # make library e.g. simple library -->\n<!-- # list learners -->\n<!-- listWrappers() -->\n\n<!-- match_lib = c(\"SL.glmnet\", \"SL.ranger\") -->\n\n\n<!-- # Set up parallel backend -->\n<!-- no_cores <- detectCores() -->\n<!-- cl <- makeCluster(no_cores - 1) -->\n\n<!-- # start parrallel -->\n<!-- registerDoParallel(cl) -->\n\n<!-- # propensity scores for censoring -->\n<!-- sl <- SuperLearner( -->\n<!--   Y = df_clean_hot$t1_lost,  -->\n<!--   X = df_clean_hot[full_predictor_vars],  # Use all specified predictors -->\n<!--   SL.library = match_lib, -->\n<!--   family = binomial(),  -->\n<!--   method = \"method.NNloglik\",  -->\n<!--   cvControl = list(V = 10) -->\n<!-- ) -->\n\n<!-- # save your model -->\n<!-- here_save(sl, \"sl\") -->\n\n<!-- # stop your cluster -->\n<!-- stopCluster(cl) -->\n\n\n<!-- # checks  -->\n<!-- print(sl)                  # prints the summary of the SuperLearner output -->\n<!-- summary(sl)                # provides a detailed summary, including cross-validated risks -->\n\n<!-- # detailed examination of cross-validated performance -->\n<!-- sl$cvRisk                  # cross-validated risks for each learner -->\n<!-- sl$coef                    # weights assigned to each learner in the final ensemble -->\n\n\n\n<!-- # generate predictions from the model -->\n<!-- predictions <- predict(sl, newdata = df_clean_hot[full_predictor_vars], type = \"response\") -->\n\n<!-- # extract predictions from the 'pred' component and ensure it's a vector -->\n<!-- df_clean_hot$pscore <- predictions$pred[, 1] -->\n\n<!-- # Check the structure of the predictions -->\n<!-- str(predictions) -->\n\n\n<!-- df_clean$cens_weights <- ifelse(df_clean_hot$t0_lost == 1, 1 / df_clean_hot$pscore, 1 / (1 - df_clean_hot$pscore)) -->\n\n\n<!-- # check  -->\n<!-- hist(df_clean$cens_weights) -->\n\n<!-- mean(df_clean$cens_weights) -->\n\n<!-- max(df_clean$cens_weights) -->\n\n<!-- min(df_clean$cens_weights) -->\n\n<!-- ### Stabalise weights -->\n\n<!-- marginal_censored<- mean(df_clean$t0_lost) -->\n\n<!-- # stabalised weights -->\n<!-- df_clean$weights_stabilised <- ifelse(df_clean_hot$t0_lost == 1, -->\n<!--                                   marginal_censored / df_clean_hot$pscore, -->\n<!--                                   (1 - marginal_censored) / (1 - df_clean_hot$pscore)) -->\n\n\n\n<!-- hist(df_clean$weights_stabilised ) -->\n<!-- min(df_clean$weights_stabilised ) -->\n<!-- max(df_clean$weights_stabilised ) -->\n\n<!-- # new weights -->\n<!-- df_clean$t0_combo_weights = df_clean$weights_stabilised * df_clean$t0_sample_weights -->\n\n<!-- min( df_clean$t0_combo_weights) -->\n<!-- max( df_clean$t0_combo_weights) -->\n\n<!-- hist( df_clean$t0_combo_weights) -->\n\n<!-- here_save(df_clean, \"df_clean\") -->\n\n<!-- # save the censored sample  -->\n\n<!-- df_clean_t2 <- df_clean |> -->\n<!--   filter(!is.na(t1_lost)) |>  -->\n<!--  select(-cens_weights, -marginal_censored) |>  -->\n<!--   select(-all_of(c(\"t0_lost\", \"t1_lost\"))) |>  -->\n<!--   relocate(starts_with(\"t0_\"), .before = starts_with(\"t1_\")) |> -->\n<!--   relocate(\"t0_censored\", .before = starts_with(\"t1_\"))  |> -->\n<!--   relocate(\"t1_censored\", .before = starts_with(\"t2_\")) |>  -->\n<!--   relocate(\"weights_stabilised\", .before = starts_with(\"t0_\")) -->\n\n<!-- colnames(df_clean_t2) -->\n<!-- here_save(df_clean_t2, \"df_clean_t2\") -->\n\n\n\n\n<!-- # Diagnostic steps -->\n<!-- print(\"Original data:\") -->\n<!-- print(str(df_impute_base$t1_perfectionism_cat)) -->\n<!-- print(table(df_impute_base$t1_perfectionism_cat, useNA = \"ifany\")) -->\n\n<!-- # Revised data cleaning code -->\n<!-- df_clean <- df_impute_base |> -->\n<!--   mutate(t0_censored = ifelse(t0_na_condition, 0, t0_censored)) |> -->\n<!--   mutate(t1_censored = ifelse(t1_na_condition, 0, t1_censored)) |> -->\n<!--   # Remove the lines that might be introducing NAs -->\n<!--   # mutate(across(starts_with(\"t1_\"), ~ ifelse(t0_censored == 0, NA, .)), -->\n<!--   #        across(starts_with(\"t2_\"), ~ ifelse(t0_censored == 0, NA, .))) |> -->\n<!--   # mutate(across(starts_with(\"t2_\"), ~ ifelse(t1_censored == 0, NA, .))) |> -->\n<!--   # Scale numeric variables, excluding t1_perfectionism_cat -->\n<!--   mutate(across(where(is.numeric) &  -->\n<!--                 !any_of(c(\"t0_censored\", \"t0_sample_weights\", \"t1_censored\", \"t1_perfectionism_cat\")),  -->\n<!--                 ~ scale(.),  -->\n<!--                 .names = \"{.col}_z\")) |> -->\n<!--   # Ensure t1_perfectionism_cat remains a factor -->\n<!--   mutate(t1_perfectionism_cat = factor(t1_perfectionism_cat,  -->\n<!--                                        levels = levels(df_impute_base$t1_perfectionism_cat), -->\n<!--                                        ordered = TRUE)) |> -->\n<!--   select( -->\n<!--     where(is.factor), -->\n<!--     t0_sample_weights, -->\n<!--     t0_censored, -->\n<!--     t1_perfectionism_cat, -->\n<!--     t1_censored, -->\n<!--     ends_with(\"_z\") -->\n<!--   ) |> -->\n<!--   mutate(t0_lost = 1 - t1_censored, -->\n<!--          t1_lost = 1 - t1_censored) |>  -->\n<!--   relocate(starts_with(\"t0_\"), .before = starts_with(\"t1_\")) |> -->\n<!--   relocate(\"t0_censored\", .before = starts_with(\"t1_\")) |> -->\n<!--   relocate(\"t1_censored\", .before = starts_with(\"t2_\")) -->\n\n<!-- # Check the result -->\n<!-- print(\"Cleaned data:\") -->\n<!-- print(str(df_clean$t1_perfectionism_cat)) -->\n<!-- print(table(df_clean$t1_perfectionism_cat, useNA = \"ifany\")) -->\n<!-- print(levels(df_clean$t1_perfectionism_cat)) -->\n\n<!-- # If NAs are still present, investigate which rows have NAs -->\n<!-- if(any(is.na(df_clean$t1_perfectionism_cat))) { -->\n<!--   print(\"Rows with NAs in t1_perfectionism_cat:\") -->\n<!--   print(df_clean[is.na(df_clean$t1_perfectionism_cat),  -->\n<!--                  c(\"t0_censored\", \"t1_censored\", \"t1_perfectionism_cat\")]) -->\n<!-- } -->\n<!-- ``` -->\n\n\n<!-- ### Matching in subgroups -->\n\n\n<!-- ### Subgroup analysis  -->\n\n<!-- ```{r} -->\n<!-- #| label: subgroup_weights -->\n<!-- #| eval: false -->\n<!-- #| echo: true -->\n\n\n<!-- hist(df_clean_filtered$sample_weights) -->\n\n<!-- # next propensity scores by groups  -->\n\n<!-- levels(df_clean_t2$t0_eth_cat) -->\n<!-- levels(df_clean_t2$t1_perfectionism_4tile) -->\n<!-- #  -->\n\n<!-- df_subgroup <-df_clean_t2 |> filter(t0_eth_cat == \"maori\" | t0_eth_cat == \"euro\") |> droplevels() -->\n\n<!-- # save -->\n<!-- here_save(df_subgroup, \"df_subgroup\") -->\n\n<!-- # check -->\n<!-- table(df_subgroup$t0_eth_cat) -->\n\n<!-- baseline_vars_models_sans_eth <- setdiff(baseline_vars_models, \"t0_eth_cat\") -->\n\n<!-- # save -->\n<!-- here_save(baseline_vars_models_sans_eth, \"baseline_vars_models_sans_eth\") -->\n\n<!-- ##  -->\n<!-- string <- formula_str <- as.formula(paste(\"t1_perfectionism_4tile\", \"~\", paste(baseline_vars_models, collapse = \"+\"))) -->\n\n<!-- string_sans <- formula_str <- as.formula(paste(\"t1_perfectionism_4tile\", \"~\", paste(baseline_vars_models_sans_eth, collapse = \"+\"))) -->\n\n<!-- W1 <- weightit( -->\n<!--   string, -->\n<!--   method = \"ipt\", -->\n<!--   estimand = \"ATT\", -->\n<!--   weights = \"weights_stabilised\", -->\n<!--   focal = \"tile_3\", -->\n<!--   # super = TRUE, -->\n<!--   #SL.library = c(\"SL.ranger\", \"SL.glmnet\", \"SL.polymars\", \"SL.xgboost\"), -->\n<!--   #super = TRUE, -->\n<!--   data = df_subgroup -->\n<!-- ) -->\n<!-- summary(W1) -->\n\n<!-- # save model -->\n<!-- here_save(W1, \"W1\") -->\n\n<!-- W2 <- weightit( -->\n<!--   string_sans, -->\n<!--   method = \"ipt\", -->\n<!--   estimand = \"ATT\", -->\n<!--   weights = \"sample_weights\", -->\n<!--   by = \"t0_eth_cat\", -->\n<!--   weights = \"sample_weights\", -->\n<!--   focal = \"tile_3\", -->\n<!-- #  super = TRUE, -->\n<!-- #  SL.library = c(\"SL.ranger\", \"SL.glmnet\", \"SL.polymars\", \"SL.xgboost\"), -->\n<!--   data = df_subgroup -->\n<!-- ) -->\n\n<!-- summary(W2) -->\n\n<!-- # save model -->\n<!-- here_save(W2, \"W2\") -->\n\n<!-- # test diff -->\n\n<!-- #S <- sbps(W1, W2) -->\n<!-- # warnings() -->\n<!-- # S -->\n<!-- ``` -->\n\n<!-- ### Evaluate subgroup weighting model -->\n\n<!-- ```{r} -->\n<!-- #| fig-width: 12 -->\n<!-- #| fig-height: 12 -->\n\n<!-- W1 <- here_read(\"W1\") -->\n<!-- W2 <- here_read(\"W2\") -->\n\n<!-- # read -->\n<!-- df_subgroup <- margot::here_read(\"df_subgroup\") -->\n\n\n\n<!-- # this method has better effective samples -->\n<!-- #bal.tab(W1) -->\n\n\n<!-- # this method has better balance -->\n<!-- # bal.tab(W2, cluster = \"t0_eth_cat\") -->\n<!-- # bal.tab(W1, cluster = \"t0_eth_cat\") -->\n<!-- # graph by cluster -->\n\n\n<!-- # W2 obtains better balance -->\n<!-- love.plot(W1,  cluster = \"t0_eth_cat\", binary = \"std\", thresholds = c(m = .1), -->\n<!--           wrap = 50, position = \"bottom\", size =2) -->\n\n<!-- love.plot(W2,  cluster = \"t0_eth_cat\", binary = \"std\", thresholds = c(m = .1), -->\n<!--           wrap = 50, position = \"bottom\", size =2) -->\n\n<!-- # check marginal too -->\n<!-- love.plot(W2,   binary = \"std\", thresholds = c(m = .1), -->\n<!--           wrap = 50, position = \"bottom\", size =2) -->\n<!-- ``` -->\n\n\n<!-- ### Parametric estimation of subgroup model -->\n\n<!-- ```{r} -->\n<!-- # prepare data -->\n\n<!-- # read vars -->\n<!-- baseline_vars_models_sans_eth <- margot::here_read(\"baseline_vars_models_sans_eth\") -->\n\n<!-- # make combo weights -->\n<!-- df_subgroup$combo_weights = W2$weights * df_subgroup$t0_combo_weights -->\n\n\n<!-- # set dataframe -->\n<!-- df = df_subgroup -->\n\n<!-- ### SUBGROUP analysis -->\n<!-- Y_anxiety = \"t2_kessler_latent_anxiety_z\" -->\n<!-- Y_depression = \"t2_kessler_latent_depression_z\" -->\n\n<!-- X = \"t1_perfectionism_4tile\" -->\n\n<!-- treat_0 = \"tile_1\" -->\n<!-- treat_1 = \"tile_3\" -->\n<!-- estimand = \"ATT\" -->\n<!-- scale = \"RD\" -->\n<!-- nsims = 1000 -->\n<!-- family = \"gaussian\" -->\n<!-- continuous_X = FALSE -->\n<!-- splines = FALSE -->\n<!-- cores = parallel::detectCores() -->\n<!-- S = \"t0_eth_cat\" -->\n\n<!-- # not we interact the subclass X treatment X covariates -->\n\n<!-- formula_str_anxiety <- -->\n<!--   paste( -->\n<!--     Y_anxiety, -->\n<!--     \"~\", -->\n<!--     S, -->\n<!--     \"*\", -->\n<!--     \"(\", -->\n<!--     X , -->\n<!--     \"*\", -->\n<!--     \"(\", -->\n<!--     paste(baseline_vars_models_sans_eth, collapse = \"+\"), -->\n<!--     \")\", -->\n<!--     \")\" -->\n<!--   ) -->\n\n<!-- formula_str_depression <- -->\n<!--   paste( -->\n<!--     Y_depression, -->\n<!--     \"~\", -->\n<!--     S, -->\n<!--     \"*\", -->\n<!--     \"(\", -->\n<!--     X , -->\n<!--     \"*\", -->\n<!--     \"(\", -->\n<!--     paste(baseline_vars_models_sans_eth, collapse = \"+\"), -->\n<!--     \")\", -->\n<!--     \")\" -->\n<!--   ) -->\n\n<!-- formula_str_anxiety -->\n<!-- formula_str_depression -->\n\n<!-- # fit model -->\n<!-- fit_all_all_anxiety  <- glm( -->\n<!--   as.formula(formula_str_anxiety), -->\n<!--   weights = combo_weights, -->\n<!--   # weights = if (!is.null(weight_var)) weight_var else NULL, -->\n<!--   family = family, -->\n<!--   data = df -->\n<!-- ) -->\n\n<!-- #summary(fit_all_all_anxiety) -->\n\n<!-- fit_all_all_depression  <- glm( -->\n<!--   as.formula(formula_str_depression), -->\n<!--   weights = combo_weights, -->\n<!--   # weights = if (!is.null(weight_var)) weight_var else NULL, -->\n<!--   family = family, -->\n<!--   data = df -->\n<!-- ) -->\n\n\n<!-- # coefs <- coef(fit_all_all_anxiety) -->\n<!-- # table(is.na(coefs))#     t0_eth_catmāori:t1_perfectionism_coarsen.Q:t0_gen_cohort.C -->\n\n<!-- # #FALSE  TRUE -->\n<!-- # 344     4 -->\n<!-- #  -->\n<!-- # insight::get_varcov(fit_all_all_anxiety) -->\n<!-- ``` -->\n\n<!-- ### Subgroup Results  -->\n\n<!-- ```{r} -->\n<!-- #| label: sim_subgroup -->\n<!-- #| eval: false -->\n<!-- #| echo: true -->\n\n<!-- # simulate coefficients -->\n<!-- sim_model_all <- sim(fit_all_all_anxiety, n = nsims, vcov = \"HC2\") -->\n\n\n<!-- # simulate effect as modified in europeans -->\n<!-- sim_estimand_all <- sim_ame( -->\n<!--   sim_model_all, -->\n<!--   var = X, -->\n<!--   cl = cores, -->\n<!--   by = \"t0_eth_cat\", -->\n<!--   verbose = FALSE -->\n<!-- ) -->\n\n<!-- # summary(sim_estimand_all) -->\n\n<!-- # make table -->\n<!-- sim_estimand_all_tab <- -->\n<!--   transform(sim_estimand_all, RD_euro = `E[Y(tile_3)|euro]` - `E[Y(tile_1)|euro]`, -->\n<!--             RD_maori =  `E[Y(tile_3)|maori]` - `E[Y(tile_1)|maori]`, -->\n<!--             gamma_hat = (`E[Y(tile_3)|euro]` - `E[Y(tile_1)|euro]`) - (`E[Y(tile_3)|maori]` - `E[Y(tile_1)|maori]`)) -->\n\n<!-- sim_estimand_all_tab -->\n<!-- # save table -->\n<!-- here_save(sim_estimand_all_tab, \"sim_estimand_all_tab\") -->\n<!-- ``` -->\n\n<!-- Summary of model -->\n\n<!-- ```{r} -->\n<!-- # read table -->\n<!-- sim_estimand_all_tab <- margot::here_read(\"sim_estimand_all_tab\") -->\n\n<!-- # print table -->\n<!-- summary(sim_estimand_all_tab) -->\n<!-- ``` -->\n\n\n<!-- ### Machine learning estimation: subgroups -->\n\n<!-- ```{r} -->\n<!-- #| label: lmtp_subgroup -->\n<!-- #| eval: false -->\n<!-- #| echo: true -->\n\n<!-- # lmtp -->\n<!-- library(\"lmtp\") -->\n\n<!-- # set number of folds for ML here. use a minimum of 5 and a max of 10 -->\n<!-- SL_folds = 5 -->\n\n<!-- #this will allow you to track progress -->\n<!-- progressr::handlers(global = TRUE) -->\n\n<!-- # set seed for reproducing results -->\n<!-- set.seed(0112358) -->\n\n<!-- # set cores for estimation -->\n<!-- library(future) -->\n<!-- plan(multisession) -->\n<!-- n_cores <- parallel::detectCores() - 2 # save two cores for other work while these models run -->\n\n<!-- # check -->\n<!-- n_cores -->\n\n<!-- # super learner libraries -->\n<!-- # these are useful for high-dimensional data -->\n\n\n<!-- df_clean_t2 <- here_read('df_clean_t2') -->\n\n<!-- df_maori <-df_clean_t2 |> dplyr::filter(t0_eth_cat == \"maori\") |> droplevels() -->\n<!-- df_euro <-df_clean_t2 |> dplyr::filter(t0_eth_cat == \"euro\")  |> droplevels() -->\n<!-- nrow(df_maori) -->\n<!-- nrow(df_euro) -->\n<!-- colnames(df_euro) -->\n\n\n<!-- colnames(df_clean_t2) -->\n\n<!-- A<- \"t1_perfectionism_4tile\" -->\n\n<!-- # note lmtp's unconventional use of \"censored\" -->\n<!-- C <- c(\"t1_censored\") -->\n\n<!-- df_clean_t2$t0_combo_weights -->\n\n<!-- names_base <- -->\n<!--   df_clean_t2 |> select(starts_with(\"t0\"), -->\n<!--                      -t0_combo_weights,  -->\n<!--                      -t0_censored, -->\n<!--                      -t0_eth_cat) |> colnames() -->\n<!-- names_base -->\n<!-- C <- c(\"t1_censored\") -->\n\n\n<!-- shift_all_tile_3 <- function(data, trt) { -->\n<!--   ifelse(data[[trt]] != \"tile_3\", \"tile_3\",  data[[trt]]) -->\n<!-- } -->\n\n\n<!-- shift_all_tile_1 <- function(data, trt) { -->\n<!--   ifelse(data[[trt]] != \"tile_1\", \"tile_1\",  data[[trt]]) -->\n<!-- } -->\n\n<!-- C -->\n\n<!-- # for faster estimation use fewer -->\n<!-- sl_lib <- c(#\"SL.glmnet\", -->\n<!--             \"SL.ranger\", # forests -->\n<!--           #  \"SL.rpart\",#  -->\n<!--             \"SL.xgboost\" -->\n<!--             )  -->\n\n<!-- ## no parametric estimation  -->\n<!-- maori_tile_3_t2_kessler_latent_anxiety_z <- lmtp_tmle( -->\n<!--     data = df_maori, -->\n<!--     trt = A, -->\n<!--     baseline = names_base, -->\n<!--     outcome = \"t2_kessler_latent_anxiety_z\", -->\n<!--     cens = C, -->\n<!--     shift = shift_all_tile_3, -->\n<!--     mtp = TRUE, -->\n<!--     folds = 5, -->\n<!--     # trim = 0.99, # if needed -->\n<!--     # time_vary = NULL, -->\n<!--     outcome_type = \"continuous\", -->\n<!--     weights = df_maori$weights_stabilised, -->\n<!--     learners_trt = sl_lib, -->\n<!--     learners_outcome =sl_lib, -->\n<!--     parallel = n_cores -->\n<!--   ) -->\n<!-- maori_tile_3_t2_kessler_latent_anxiety_z -->\n<!-- here_save(maori_tile_3_t2_kessler_latent_anxiety_z, \"maori_tile_3_t2_kessler_latent_anxiety_z\") -->\n\n<!-- # learners for the exposure -->\n<!-- maori_tile_3_t2_kessler_latent_anxiety_z$fits_m -->\n\n<!-- # learners for the  outcome -->\n<!-- maori_tile_3_t2_kessler_latent_anxiety_z$fits_r -->\n\n\n<!-- maori_tile_1_t2_kessler_latent_anxiety_z <- lmtp_tmle( -->\n<!--     data = df_maori, -->\n<!--     trt = A, -->\n<!--     baseline = names_base, -->\n<!--     outcome = \"t2_kessler_latent_anxiety_z\", -->\n<!--     cens = C, -->\n<!--     shift = shift_all_tile_1, -->\n<!--     mtp = TRUE, -->\n<!--     folds = 5, -->\n<!--     # trim = 0.99, # if needed -->\n<!--     # time_vary = NULL, -->\n<!--     outcome_type = \"continuous\", -->\n<!--     weights = df_maori$weights_stabilised, -->\n<!--     learners_trt = sl_lib, -->\n<!--     learners_outcome =sl_lib, -->\n<!--     parallel = n_cores -->\n<!--   ) -->\n<!-- maori_tile_1_t2_kessler_latent_anxiety_z -->\n<!-- here_save(maori_tile_1_t2_kessler_latent_anxiety_z, \"maori_tile_1_t2_kessler_latent_anxiety_z\") -->\n\n<!-- # higher anxiety  -->\n<!-- maori_results <-lmtp_contrast(maori_tile_3_t2_kessler_latent_anxiety_z, ref = maori_tile_1_t2_kessler_latent_anxiety_z) -->\n<!-- # maori_results -->\n<!-- here_save(maori_results, \"maori_results\") -->\n\n<!-- euro_tile_3_t2_kessler_latent_anxiety_z <- lmtp_tmle( -->\n<!--     data = df_euro, -->\n<!--     trt = A, -->\n<!--     baseline = names_base, -->\n<!--     outcome = \"t2_kessler_latent_anxiety_z\", -->\n<!--     cens = C, -->\n<!--     shift = shift_all_tile_3, -->\n<!--     mtp = TRUE, -->\n<!--     folds = 5, -->\n<!--     # trim = 0.99, # if needed -->\n<!--     # time_vary = NULL, -->\n<!--     outcome_type = \"continuous\", -->\n<!--     weights = df_euro$weights_stabilised, -->\n<!--     learners_trt = sl_lib, -->\n<!--     learners_outcome =sl_lib, -->\n<!--     parallel = n_cores -->\n<!--   ) -->\n<!-- euro_tile_3_t2_kessler_latent_anxiety_z -->\n<!-- here_save(euro_tile_3_t2_kessler_latent_anxiety_z, \"euro_tile_3_t2_kessler_latent_anxiety_z\") -->\n\n\n<!-- euro_tile_1_t2_kessler_latent_anxiety_z <- lmtp_tmle( -->\n<!--     data = df_euro, -->\n<!--     trt = A, -->\n<!--     baseline = names_base, -->\n<!--     outcome = \"t2_kessler_latent_anxiety_z\", -->\n<!--     cens = C, -->\n<!--     shift = shift_all_tile_1, -->\n<!--     mtp = TRUE, -->\n<!--     folds = 5, -->\n<!--     # trim = 0.99, # if needed -->\n<!--     # time_vary = NULL, -->\n<!--     outcome_type = \"continuous\", -->\n<!--     weights = df_euro$weights_stabilised, -->\n<!--     learners_trt = sl_lib, -->\n<!--     learners_outcome =sl_lib, -->\n<!--     parallel = n_cores -->\n<!--   ) -->\n<!-- euro_tile_1_t2_kessler_latent_anxiety_z -->\n<!-- here_save(euro_tile_1_t2_kessler_latent_anxiety_z, \"euro_tile_1_t2_kessler_latent_anxiety_z\") -->\n\n\n<!-- euro_results <- lmtp_contrast(euro_tile_3_t2_kessler_latent_anxiety_z, ref = euro_tile_1_t2_kessler_latent_anxiety_z) -->\n<!-- here_save(euro_results, \"euro_results\") -->\n\n<!-- ``` -->\n\n\n<!-- ### Machine learning: results -->\n\n<!-- No difference between groups.  -->\n\n<!-- ```{r} -->\n<!-- euro_results <- margot::here_read(\"euro_results\") -->\n<!-- maori_results<- margot::here_read(\"maori_results\") -->\n\n<!-- euro_results -->\n<!-- maori_results -->\n\n<!-- g_hat_theta= euro_results$vals$theta - maori_results$vals$theta  -->\n<!-- g_hat_theta # difference of means -->\n<!-- euro_results$vals$std.error -->\n<!-- # difference  -->\n<!-- se_diff = sqrt( (euro_results$vals$std.error^2) + (maori_results$vals$std.error^2) ) -->\n\n<!-- diff_conf.low = g_hat_theta - (1.97 * se_diff) -->\n<!-- diff_conf.high = g_hat_theta + (1.97 * se_diff) -->\n\n\n<!-- g_hat_anxiety <- cbind.data.frame(g_hat_theta, se_diff, diff_conf.low, diff_conf.high) -->\n\n<!-- # result -->\n<!-- g_hat_anxiety -->\n<!-- ``` -->\n\n\n<!-- Note, however that the invevention increases anxiety for both groups equally -->\n\n\n<!-- ### Europeans results -->\n\n<!-- ```{r} -->\n<!-- euro_results <- margot::here_read(\"euro_results\") -->\n<!-- round( euro_results$vals, 3) -->\n<!-- ``` -->\n\n\n<!-- ### Maori results -->\n\n<!-- ```{r} -->\n<!-- maori_results<- margot::here_read(\"maori_results\") -->\n<!-- round(maori_results$vals, 3) -->\n\n\n\n<!-- ``` -->\n\n\n<!-- ### Graph results -->\n\n<!-- ```{r} -->\n<!-- tab_euro_results <- margot::margot_lmtp_evalue( -->\n<!--   euro_results, -->\n<!--   scale = \"RD\", -->\n<!--   new_name = \"Euro: 1_tile to 3_tile\" -->\n<!-- ) -->\n\n\n\n<!-- tab_maori_results <- margot::margot_lmtp_evalue( -->\n<!--   maori_results, -->\n<!--   scale = \"RD\", -->\n<!--   new_name = \"Māori: 1_tile to 3_tile\" -->\n<!-- ) -->\n\n<!-- bind_results_anxiety <- rbind(tab_euro_results, tab_maori_results) -->\n\n<!-- here_save(bind_results_anxiety, \"bind_results_anxiety\") -->\n\n<!-- ``` -->\n\n\n<!-- ```{r} -->\n<!-- #| fig-width: 10 -->\n<!-- #| fig-height: 12 -->\n\n<!-- bind_results_anxiety <- here_read(\"bind_results_anxiety\") -->\n<!-- group_tab_anxiety <- margot::group_tab(bind_results_anxiety, type = \"RD\") -->\n<!-- conflicted::conflicts_prefer(ggplot2::margin) -->\n<!-- # graph results -->\n<!--  margot_plot( -->\n<!--   group_tab_anxiety, -->\n<!--   type = \"RD\", -->\n<!--   title = \"Perfectionism: shift all to 3_tile, contrast with 1_tile\", -->\n<!--   subtitle = \"Outcome = Anxiety\", -->\n<!--   estimate_scale = 1, -->\n<!--   base_size = 18, -->\n<!--   text_size = 4.5, -->\n<!--   point_size = 3.5, -->\n<!--   title_size = 20, -->\n<!--   subtitle_size = 16, -->\n<!--   legend_text_size = 10, -->\n<!--   legend_title_size = 10, -->\n<!--   x_offset = -.5, -->\n<!--   x_lim_lo = -.5, -->\n<!--   x_lim_hi =  .5 -->\n<!-- ) -->\n<!-- ``` -->\n\n\n<!-- Interpret Results -->\n\n\n<!-- ```{r} -->\n<!-- margot_interpret_table(group_tab_anxiety, estimand = \"ATT\", causal_scale = \"causal_difference\") -->\n<!-- ``` -->\n\n\n<!-- ## Take Home Message -->\n\n<!-- Machine learning with cross validation recovers nearly identical estimates for the effect of a shift in perfectionism on anxiety among Māori and Europeans.  -->\n\n<!-- Which results are correct?  We don't know. With more time, we would add more learners to the model, including parametric learners.  -->\n\n\n<!-- Generally, I suggest using machine learning algorithms, because they can include parametric estimators.  -->\n\n\n\n### Packages\n\n::: {.cell}\n\n```{.r .cell-code}\nreport::cite_packages()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  - Analytics R, Weston S (2022). _iterators: Provides Iterator Construct_. R package version 1.0.14, <https://CRAN.R-project.org/package=iterators>.\n  - Bulbulia J (2024). _margot: MARGinal Observational Treatment-effects_. doi:10.5281/zenodo.10907724 <https://doi.org/10.5281/zenodo.10907724>, R package version 0.3.1.1 Functions to obtain MARGinal Observational Treatment-effects from observational data., <https://go-bayes.github.io/margot/>.\n  - Chang W (2023). _extrafont: Tools for Using Fonts_. R package version 0.19, <https://CRAN.R-project.org/package=extrafont>.\n  - Chen T, He T, Benesty M, Khotilovich V, Tang Y, Cho H, Chen K, Mitchell R, Cano I, Zhou T, Li M, Xie J, Lin M, Geng Y, Li Y, Yuan J (2024). _xgboost: Extreme Gradient Boosting_. R package version 1.7.8.1, <https://CRAN.R-project.org/package=xgboost>.\n  - Corporation M, Weston S (2022). _doParallel: Foreach Parallel Adaptor for the 'parallel' Package_. R package version 1.0.17, <https://CRAN.R-project.org/package=doParallel>.\n  - Csárdi G (2024). _cli: Helpers for Developing Command Line Interfaces_. R package version 3.6.3, <https://CRAN.R-project.org/package=cli>.\n  - Csárdi G (2024). _crayon: Colored Terminal Output_. R package version 1.5.3, <https://CRAN.R-project.org/package=crayon>.\n  - Greifer N (2024). _cobalt: Covariate Balance Tables and Plots_. R package version 4.5.5, <https://CRAN.R-project.org/package=cobalt>.\n  - Greifer N (2024). _WeightIt: Weighting for Covariate Balance in Observational Studies_. R package version 1.3.2, <https://CRAN.R-project.org/package=WeightIt>.\n  - Greifer N, Worthington S, Iacus S, King G (2024). _clarify: Simulation-Based Inference for Regression Models_. R package version 0.2.1, <https://CRAN.R-project.org/package=clarify>.\n  - Grolemund G, Wickham H (2011). \"Dates and Times Made Easy with lubridate.\" _Journal of Statistical Software_, *40*(3), 1-25. <https://www.jstatsoft.org/v40/i03/>.\n  - Hastie T (2024). _gam: Generalized Additive Models_. R package version 1.22-5, <https://CRAN.R-project.org/package=gam>.\n  - Ho D, Imai K, King G, Stuart E (2011). \"MatchIt: Nonparametric Preprocessing for Parametric Causal Inference.\" _Journal of Statistical Software_, *42*(8), 1-28. doi:10.18637/jss.v042.i08 <https://doi.org/10.18637/jss.v042.i08>.\n  - Microsoft, Weston S (2022). _foreach: Provides Foreach Looping Construct_. R package version 1.5.2, <https://CRAN.R-project.org/package=foreach>.\n  - Mullen KM, van Stokkum IHM (2024). _nnls: The Lawson-Hanson Algorithm for Non-Negative Least Squares (NNLS)_. R package version 1.6, <https://CRAN.R-project.org/package=nnls>.\n  - Müller K, Wickham H (2023). _tibble: Simple Data Frames_. R package version 3.2.1, <https://CRAN.R-project.org/package=tibble>.\n  - Pishgar F, Greifer N, Leyrat C, Stuart E (2021). \"MatchThem:: Matching and Weighting after Multiple Imputation.\" _The R Journal_. doi:10.32614/RJ-2021-073 <https://doi.org/10.32614/RJ-2021-073>, <https://journal.r-project.org/archive/2021/RJ-2021-073/>.\n  - Polley E, LeDell E, Kennedy C, van der Laan M (2024). _SuperLearner: Super Learner Prediction_. R package version 2.0-29, <https://CRAN.R-project.org/package=SuperLearner>.\n  - R Core Team (2024). _R: A Language and Environment for Statistical Computing_. R Foundation for Statistical Computing, Vienna, Austria. <https://www.R-project.org/>.\n  - Tierney N, Cook D (2023). \"Expanding Tidy Data Principles to Facilitate Missing Data Exploration, Visualization and Assessment of Imputations.\" _Journal of Statistical Software_, *105*(7), 1-31. doi:10.18637/jss.v105.i07 <https://doi.org/10.18637/jss.v105.i07>.\n  - van Buuren S, Groothuis-Oudshoorn K (2011). \"mice: Multivariate Imputation by Chained Equations in R.\" _Journal of Statistical Software_, *45*(3), 1-67. doi:10.18637/jss.v045.i03 <https://doi.org/10.18637/jss.v045.i03>.\n  - Waring E, Quinn M, McNamara A, Arino de la Rubia E, Zhu H, Ellis S (2022). _skimr: Compact and Flexible Summaries of Data_. R package version 2.1.5, <https://CRAN.R-project.org/package=skimr>.\n  - Wickham H (2016). _ggplot2: Elegant Graphics for Data Analysis_. Springer-Verlag New York. ISBN 978-3-319-24277-4, <https://ggplot2.tidyverse.org>.\n  - Wickham H (2023). _forcats: Tools for Working with Categorical Variables (Factors)_. R package version 1.0.0, <https://CRAN.R-project.org/package=forcats>.\n  - Wickham H (2023). _stringr: Simple, Consistent Wrappers for Common String Operations_. R package version 1.5.1, <https://CRAN.R-project.org/package=stringr>.\n  - Wickham H, Averick M, Bryan J, Chang W, McGowan LD, François R, Grolemund G, Hayes A, Henry L, Hester J, Kuhn M, Pedersen TL, Miller E, Bache SM, Müller K, Ooms J, Robinson D, Seidel DP, Spinu V, Takahashi K, Vaughan D, Wilke C, Woo K, Yutani H (2019). \"Welcome to the tidyverse.\" _Journal of Open Source Software_, *4*(43), 1686. doi:10.21105/joss.01686 <https://doi.org/10.21105/joss.01686>.\n  - Wickham H, François R, Henry L, Müller K, Vaughan D (2023). _dplyr: A Grammar of Data Manipulation_. R package version 1.1.4, <https://CRAN.R-project.org/package=dplyr>.\n  - Wickham H, Henry L (2025). _purrr: Functional Programming Tools_. R package version 1.0.4, <https://CRAN.R-project.org/package=purrr>.\n  - Wickham H, Hester J, Bryan J (2024). _readr: Read Rectangular Text Data_. R package version 2.1.5, <https://CRAN.R-project.org/package=readr>.\n  - Wickham H, Vaughan D, Girlich M (2024). _tidyr: Tidy Messy Data_. R package version 1.3.1, <https://CRAN.R-project.org/package=tidyr>.\n  - Williams N, Díaz I (2023). \"lmtp: An R package for estimating the causal effects of modified treatment policies.\" _Observational Studies_. <https://muse.jhu.edu/article/883479>. Díaz I, Williams N, Hoffman K, Schneck E (2021). \"Non-parametric causal effects based on longitudinal modified treatment policies.\" _Journal of the American Statistical Association_. doi:10.1080/01621459.2021.1955691 <https://doi.org/10.1080/01621459.2021.1955691>.\n  - Wright MN, Ziegler A (2017). \"ranger: A Fast Implementation of Random Forests for High Dimensional Data in C++ and R.\" _Journal of Statistical Software_, *77*(1), 1-17. doi:10.18637/jss.v077.i01 <https://doi.org/10.18637/jss.v077.i01>.\n  - Xie Y (2024). _knitr: A General-Purpose Package for Dynamic Report Generation in R_. R package version 1.49, <https://yihui.org/knitr/>. Xie Y (2015). _Dynamic Documents with R and knitr_, 2nd edition. Chapman and Hall/CRC, Boca Raton, Florida. ISBN 978-1498716963, <https://yihui.org/knitr/>. Xie Y (2014). \"knitr: A Comprehensive Tool for Reproducible Research in R.\" In Stodden V, Leisch F, Peng RD (eds.), _Implementing Reproducible Computational Research_. Chapman and Hall/CRC. ISBN 978-1466561595.\n  - Xie Y (2024). _tinytex: Helper Functions to Install and Maintain TeX Live, and Compile LaTeX Documents_. R package version 0.54, <https://github.com/rstudio/tinytex>. Xie Y (2019). \"TinyTeX: A lightweight, cross-platform, and easy-to-maintain LaTeX distribution based on TeX Live.\" _TUGboat_, *40*(1), 30-32. <https://tug.org/TUGboat/Contents/contents40-1.html>.\n  - Zhu H (2024). _kableExtra: Construct Complex Table with 'kable' and Pipe Syntax_. R package version 1.4.0, <https://CRAN.R-project.org/package=kableExtra>.\n```\n\n\n:::\n:::\n\n\n\n",
    "supporting": [
      "08-content_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}